<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FrameNote v0.4.1 - Text-First Slide Tool</title>
  <!-- Load all libraries BEFORE Monaco's AMD loader -->
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <!-- Monaco loader MUST be loaded last to avoid AMD conflicts -->
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Noto+Sans+JP:wght@400;500;700&family=Inter:wght@400;500;600;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+1p:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&family=Zen+Maru+Gothic:wght@400;700&family=BIZ+UDGothic:wght@400;700&family=Shippori+Mincho:wght@400;700&family=Klee+One:wght@400;600&family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Playfair+Display:wght@400;700&family=Fira+Code:wght@400;500&family=Source+Code+Pro:wght@400;500&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0f0f0f;
      --bg-panel: #1a1a1a;
      --bg-surface: #242424;
      --bg-hover: #2d2d2d;
      --border: #333;
      --border-focus: #58a6ff;
      --text-primary: #e6e6e6;
      --text-secondary: #999;
      --text-muted: #666;
      --accent: #58a6ff;
      --accent-hover: #79b8ff;
      --success: #3fb950;
      --warning: #d29922;
      --error: #f85149;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
    }

    /* Header */
    .header {
      height: 48px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--accent), #a855f7);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: white;
    }

    .logo h1 {
      font-size: 16px;
      font-weight: 600;
    }

    .logo-version {
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 400;
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn:hover {
      background: var(--bg-hover);
      border-color: var(--text-muted);
    }

    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    .theme-selector {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-right: 16px;
      padding-right: 16px;
      border-right: 1px solid var(--border);
    }

    .theme-selector label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    #theme-select, #font-select {
      padding: 6px 24px 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background-color: var(--bg-surface);
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 4px center;
      background-repeat: no-repeat;
      background-size: 16px;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      min-width: 120px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    #theme-select:hover, #font-select:hover {
      border-color: var(--text-muted);
    }

    #theme-select:focus, #font-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    #theme-select option, #font-select option {
      background: var(--bg-panel);
      color: var(--text-primary);
      padding: 8px;
    }

    /* Main Layout */
    .main {
      display: flex;
      height: calc(100vh - 48px);
    }

    /* Sidebar */
    .sidebar {
      width: 200px;
      background: var(--bg-panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }

    .sidebar-header {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .outline-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .outline-item {
      padding: 8px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      color: var(--text-secondary);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px;
    }

    .outline-item:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .outline-item.active {
      background: var(--bg-surface);
      color: var(--accent);
    }

    .outline-item.has-error {
      color: var(--error);
    }

    .outline-number {
      font-size: 10px;
      color: var(--text-muted);
      min-width: 18px;
    }

    .outline-template {
      font-size: 9px;
      padding: 2px 5px;
      background: var(--bg-hover);
      border-radius: 3px;
      color: var(--text-muted);
      margin-left: auto;
    }

    /* Editor Panel */
    .editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .editor-tabs {
      display: flex;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
    }

    .editor-tab {
      padding: 10px 16px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.15s;
    }

    .editor-tab:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    .editor-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .editor-content {
      flex: 1;
      display: none;
    }

    .editor-content.active {
      display: flex;
      flex-direction: column;
    }

    #monaco-container {
      flex: 1;
    }

    /* Images Panel */
    .images-panel {
      padding: 16px;
      overflow-y: auto;
    }

    .image-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
      margin-bottom: 16px;
    }

    .image-dropzone:hover,
    .image-dropzone.dragover {
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.05);
    }

    .image-dropzone-text {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 12px;
    }

    .image-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 6px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }

    .image-item:hover {
      border-color: var(--accent);
    }

    .image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .image-item-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 4px 6px;
      background: rgba(0, 0, 0, 0.8);
      font-size: 10px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .image-item-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(248, 81, 73, 0.9);
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .image-item:hover .image-item-delete {
      display: flex;
    }

    /* Preview Panel */
    .preview-panel {
      width: 50%;
      background: var(--bg-dark);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }

    .preview-header {
      padding: 10px 16px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-title {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .preview-nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .preview-nav-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-surface);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .preview-nav-btn:hover {
      background: var(--bg-hover);
    }

    .preview-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .preview-page {
      font-size: 12px;
      color: var(--text-secondary);
      min-width: 60px;
      text-align: center;
    }

    .preview-container {
      flex: 1;
      padding: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .slide-frame {
      width: 100%;
      max-width: 800px;
      aspect-ratio: 16 / 9;
      background: white;
      border-radius: 4px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
      overflow: hidden;
    }

    .slide-frame svg {
      width: 100%;
      height: 100%;
    }

    /* Validation Panel */
    .validation-panel {
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      max-height: 150px;
      overflow-y: auto;
    }

    .validation-header {
      padding: 8px 12px;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
    }

    .validation-list {
      padding: 8px;
    }

    .validation-item {
      padding: 6px 8px;
      font-size: 11px;
      border-radius: 4px;
      margin-bottom: 4px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .validation-item.error {
      background: rgba(248, 81, 73, 0.1);
      color: var(--error);
    }

    .validation-item.warning {
      background: rgba(210, 153, 34, 0.1);
      color: var(--warning);
    }

    .validation-item.success {
      background: rgba(63, 185, 80, 0.1);
      color: var(--success);
    }

    /* Slideshow Modal */
    .slideshow-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 1000;
      display: none;
      flex-direction: column;
    }

    .slideshow-modal.active {
      display: flex;
    }

    .slideshow-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      cursor: none;
    }

    .slideshow-content:hover {
      cursor: default;
    }

    .slideshow-slide {
      width: 100%;
      height: 100%;
      max-width: calc((100vh - 40px) * 16 / 9);
      max-height: calc(100vw * 9 / 16);
      aspect-ratio: 16 / 9;
      background: white;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(0,0,0,0.8);
    }

    .slideshow-slide svg {
      width: 100%;
      height: 100%;
    }

    .slideshow-controls {
      padding: 15px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      background: rgba(0,0,0,0.9);
      transition: opacity 0.3s, transform 0.3s;
    }

    .slideshow-modal.fullscreen .slideshow-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      opacity: 0;
      transform: translateY(100%);
    }

    .slideshow-modal.fullscreen:hover .slideshow-controls,
    .slideshow-modal.fullscreen .slideshow-controls:focus-within {
      opacity: 1;
      transform: translateY(0);
    }

    .slideshow-modal.fullscreen .slideshow-content {
      padding: 0;
    }

    .slideshow-modal.fullscreen .slideshow-slide {
      max-width: calc(100vh * 16 / 9);
      max-height: 100vh;
      border-radius: 0;
      box-shadow: none;
    }

    .slideshow-btn {
      padding: 10px 20px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #1a1a1a;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .slideshow-btn:hover {
      background: #2d2d2d;
    }

    .slideshow-page {
      font-size: 14px;
      color: #999;
      min-width: 80px;
      text-align: center;
    }

    /* Notification */
    .notification {
      position: fixed;
      top: 60px;
      right: 16px;
      padding: 12px 16px;
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
      z-index: 100;
      animation: slideIn 0.2s ease;
    }

    .notification.success {
      border-color: var(--success);
      color: var(--success);
    }

    .notification.error {
      border-color: var(--error);
      color: var(--error);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-dark);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-focus);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo">
      <div class="logo-icon">F</div>
      <h1>FrameNote <span class="logo-version">v0.4.1</span></h1>
    </div>
    <div class="header-actions">
      <div class="theme-selector">
        <label for="theme-select">Theme:</label>
        <select id="theme-select">
          <option value="default">Default</option>
          <option value="corporate">Corporate</option>
          <option value="minimal">Minimal</option>
          <option value="dark">Dark</option>
          <option value="nature">Nature</option>
          <option value="sunset">Sunset</option>
          <option value="ocean">Ocean</option>
          <option value="lavender">Lavender</option>
          <option value="rose">Rose</option>
          <option value="midnight">Midnight</option>
        </select>
      </div>
      <div class="theme-selector">
        <label for="font-select">Font:</label>
        <select id="font-select">
          <option value="sans">„Ç¥„Ç∑„ÉÉ„ÇØ (Noto Sans JP)</option>
          <option value="serif">ÊòéÊúù (Noto Serif JP)</option>
          <option value="rounded">‰∏∏„Ç¥„Ç∑„ÉÉ„ÇØ (M PLUS Rounded)</option>
          <option value="business">„Éì„Ç∏„Éç„Çπ (BIZ UDGothic)</option>
          <option value="modern">„É¢„ÉÄ„É≥ (Montserrat + Noto)</option>
          <option value="elegant">„Ç®„É¨„Ç¨„É≥„Éà (Playfair + Shippori)</option>
          <option value="handwritten">ÊâãÊõ∏„ÅçÈ¢® (Klee One)</option>
        </select>
      </div>
      <button class="btn" onclick="openProject()">üìÇ Open</button>
      <button class="btn" onclick="saveProject()">üíæ Save</button>
      <button class="btn" onclick="exportPDF()">üìÑ PDF</button>
      <button class="btn" onclick="exportPPTX()">üìä PPTX</button>
      <button class="btn" onclick="exportHTML()">üåê HTML</button>
      <button class="btn" onclick="loadSample()">üìã Sample</button>
      <button class="btn btn-primary" onclick="startSlideshow()">‚ñ∂ Present</button>
    </div>
  </header>

  <main class="main">
    <aside class="sidebar">
      <div class="sidebar-header">Outline</div>
      <div class="outline-list" id="outline-list"></div>
    </aside>

    <section class="editor-panel">
      <div class="editor-tabs">
        <div class="editor-tab active" data-tab="editor">PDL Editor</div>
        <div class="editor-tab" data-tab="images">Images</div>
      </div>
      
      <div class="editor-content active" data-content="editor">
        <div id="monaco-container"></div>
      </div>
      
      <div class="editor-content" data-content="images">
        <div class="images-panel">
          <div class="image-dropzone" id="image-dropzone">
            <div class="image-dropzone-text">
              Drop images here or click to upload
            </div>
          </div>
          <div class="image-grid" id="image-grid"></div>
        </div>
      </div>

      <div class="validation-panel">
        <div class="validation-header">
          <span>Validation</span>
          <span id="validation-count"></span>
        </div>
        <div class="validation-list" id="validation-list"></div>
      </div>
    </section>

    <section class="preview-panel">
      <div class="preview-header">
        <span class="preview-title">Preview</span>
        <div class="preview-nav">
          <button class="preview-nav-btn" onclick="prevSlide()">‚óÄ</button>
          <span class="preview-page" id="preview-page">1 / 1</span>
          <button class="preview-nav-btn" onclick="nextSlide()">‚ñ∂</button>
        </div>
      </div>
      <div class="preview-container">
        <div class="slide-frame" id="slide-frame"></div>
      </div>
    </section>
  </main>

  <div class="slideshow-modal" id="slideshow-modal">
    <div class="slideshow-content" onclick="handleSlideshowClick(event)">
      <div class="slideshow-slide" id="slideshow-slide"></div>
    </div>
    <div class="slideshow-controls">
      <button class="slideshow-btn" onclick="prevSlideshowSlide()">‚óÄ Prev</button>
      <span class="slideshow-page" id="slideshow-page">1 / 1</span>
      <button class="slideshow-btn" onclick="nextSlideshowSlide()">Next ‚ñ∂</button>
      <button class="slideshow-btn" onclick="toggleFullscreen()" id="fullscreen-btn">‚õ∂ Fullscreen</button>
      <button class="slideshow-btn" onclick="endSlideshow()">‚úï Exit</button>
    </div>
  </div>

  <input type="file" id="file-input" accept=".fnote,.yaml,.yml" style="display:none">
  <input type="file" id="image-input" accept="image/*" multiple style="display:none">

  <script>
    // Theme definitions - Modern color schemes
    const THEMES = {
      default: {
        name: 'Default',
        background: '#fafbfc',
        accent: '#6366f1',
        title: '#1e1b4b',
        text: '#334155',
        bullet: '#6366f1',
        muted: '#64748b',
        headerBg: '#f1f5f9',
        footerBg: '#f1f5f9'
      },
      corporate: {
        name: 'Corporate',
        background: '#f8fafc',
        accent: '#0ea5e9',
        title: '#0c4a6e',
        text: '#334155',
        bullet: '#0ea5e9',
        muted: '#64748b',
        headerBg: '#e0f2fe',
        footerBg: '#e0f2fe'
      },
      minimal: {
        name: 'Minimal',
        background: '#ffffff',
        accent: '#18181b',
        title: '#09090b',
        text: '#3f3f46',
        bullet: '#71717a',
        muted: '#a1a1aa',
        headerBg: '#fafafa',
        footerBg: '#fafafa'
      },
      dark: {
        name: 'Dark',
        background: '#0f172a',
        accent: '#38bdf8',
        title: '#f1f5f9',
        text: '#cbd5e1',
        bullet: '#38bdf8',
        muted: '#64748b',
        headerBg: '#1e293b',
        footerBg: '#1e293b'
      },
      nature: {
        name: 'Nature',
        background: '#f0fdf4',
        accent: '#16a34a',
        title: '#14532d',
        text: '#365314',
        bullet: '#22c55e',
        muted: '#65a30d',
        headerBg: '#dcfce7',
        footerBg: '#dcfce7'
      },
      sunset: {
        name: 'Sunset',
        background: '#fff7ed',
        accent: '#f97316',
        title: '#9a3412',
        text: '#431407',
        bullet: '#fb923c',
        muted: '#78716c',
        headerBg: '#ffedd5',
        footerBg: '#ffedd5'
      },
      ocean: {
        name: 'Ocean',
        background: '#f0f9ff',
        accent: '#0284c7',
        title: '#0c4a6e',
        text: '#1e3a5f',
        bullet: '#06b6d4',
        muted: '#64748b',
        headerBg: '#e0f2fe',
        footerBg: '#e0f2fe'
      },
      lavender: {
        name: 'Lavender',
        background: '#faf5ff',
        accent: '#a855f7',
        title: '#581c87',
        text: '#3b0764',
        bullet: '#c084fc',
        muted: '#6b7280',
        headerBg: '#f3e8ff',
        footerBg: '#f3e8ff'
      },
      rose: {
        name: 'Rose',
        background: '#fff1f2',
        accent: '#f43f5e',
        title: '#881337',
        text: '#4c0519',
        bullet: '#fb7185',
        muted: '#71717a',
        headerBg: '#ffe4e6',
        footerBg: '#ffe4e6'
      },
      midnight: {
        name: 'Midnight',
        background: '#020617',
        accent: '#a78bfa',
        title: '#e2e8f0',
        text: '#94a3b8',
        bullet: '#a78bfa',
        muted: '#475569',
        headerBg: '#0f172a',
        footerBg: '#0f172a'
      }
    };

    // Global state
    let monacoEditor = null;
    let currentSlide = 0;
    let parsedData = null;
    let uploadedImages = new Map();
    let slideshowSlide = 0;
    let currentTheme = 'default';
    let currentFont = 'sans';
    let themeChangedByUI = false;  // „Éï„É©„Ç∞: UI„Çª„É¨„ÇØ„Çø„Éº„Åã„Çâ„ÅÆÂ§âÊõ¥„Åã
    let fontChangedByUI = false;   // „Éï„É©„Ç∞: UI„Çª„É¨„ÇØ„Çø„Éº„Åã„Çâ„ÅÆÂ§âÊõ¥„Åã

    // Font presets
    const FONT_PRESETS = {
      sans: {
        heading: 'Noto Sans JP',
        body: 'Noto Sans JP',
        code: 'Fira Code'
      },
      serif: {
        heading: 'Noto Serif JP',
        body: 'Noto Serif JP',
        code: 'Source Code Pro'
      },
      rounded: {
        heading: 'M PLUS Rounded 1c',
        body: 'M PLUS 1p',
        code: 'Fira Code'
      },
      business: {
        heading: 'BIZ UDGothic',
        body: 'BIZ UDGothic',
        code: 'Roboto Mono'
      },
      modern: {
        heading: 'Montserrat',
        body: 'Noto Sans JP',
        code: 'JetBrains Mono'
      },
      elegant: {
        heading: 'Playfair Display',
        body: 'Shippori Mincho',
        code: 'Source Code Pro'
      },
      handwritten: {
        heading: 'Klee One',
        body: 'Klee One',
        code: 'Fira Code'
      }
    };

    // Available fonts list
    const AVAILABLE_FONTS = {
      japanese: [
        'Noto Sans JP',
        'Noto Serif JP',
        'M PLUS 1p',
        'M PLUS Rounded 1c',
        'Zen Maru Gothic',
        'BIZ UDGothic',
        'Shippori Mincho',
        'Klee One'
      ],
      latin: [
        'Inter',
        'Roboto',
        'Montserrat',
        'Open Sans',
        'Lato',
        'Playfair Display'
      ],
      code: [
        'Fira Code',
        'Source Code Pro',
        'JetBrains Mono',
        'Roboto Mono'
      ]
    };

    // Get font settings from meta or UI
    function getFontSettings(meta) {
      // Priority: UI selector > meta.font > default
      // (UI takes priority when user explicitly changes it)
      let fonts = FONT_PRESETS[currentFont] || FONT_PRESETS.sans;
      
      if (meta?.font) {
        if (typeof meta.font === 'string') {
          // Preset name or single font
          if (FONT_PRESETS[meta.font]) {
            // Only use meta.font if UI hasn't been changed
            if (!fontChangedByUI) {
              fonts = FONT_PRESETS[meta.font];
            }
          } else {
            // Single font name for all (custom font)
            fonts = {
              heading: meta.font,
              body: meta.font,
              code: 'Fira Code'
            };
          }
        } else if (typeof meta.font === 'object') {
          // Detailed font settings
          fonts = {
            heading: meta.font.heading || fonts.heading,
            body: meta.font.body || fonts.body,
            code: meta.font.code || fonts.code
          };
        }
      }
      
      return fonts;
    }

    // Font change handler
    function changeFont(fontPreset) {
      fontChangedByUI = true;
      currentFont = fontPreset;
      parseAndRender();
    }

    // Theme functions
    function changeTheme(themeName) {
      themeChangedByUI = true;
      currentTheme = themeName;
      parseAndRender();
    }

    function getThemeColors(meta) {
      // Priority: slide format > meta format > UI selector > default
      const uiTheme = THEMES[currentTheme] || THEMES.default;
      
      // Apply meta.format overrides
      const format = meta?.format || {};
      
      return {
        background: format.background?.color || uiTheme.background,
        accent: format.accent?.color || uiTheme.accent,
        title: format.title?.color || uiTheme.title,
        titleSize: format.title?.size || 48,
        titleWeight: format.title?.weight || '700',
        text: format.text?.color || uiTheme.text,
        textSize: format.text?.size || 28,
        bullet: format.bullet?.color || uiTheme.bullet,
        muted: uiTheme.muted,
        headerBg: uiTheme.headerBg,
        footerBg: uiTheme.footerBg
      };
    }

    // Initialize Monaco Editor
    require.config({ 
      paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' }
    });
    
    // Properly configure Monaco to not use web workers
    window.MonacoEnvironment = {
      getWorkerUrl: function() {
        return 'data:text/javascript;charset=utf-8,' + encodeURIComponent('self.onmessage = function() {}');
      }
    };

    require(['vs/editor/editor.main'], function() {
      // Register PDL language
      monaco.languages.register({ id: 'pdl' });
      
      monaco.languages.setMonarchTokensProvider('pdl', {
        tokenizer: {
          root: [
            [/^meta:/, 'keyword'],
            [/^slides:/, 'keyword'],
            [/^\s*-\s+title:/, 'keyword'],
            [/^\s*-\s+template:/, 'keyword.template'],
            [/^\s+(template|title|subtitle|body|style|figure|caption|text|notes|format|quote|author|source|contact|message|items|events|left|right|label|date):/, 'keyword'],
            [/^\s+(header|footer|show|logo|center|theme):/, 'keyword.meta'],
            [/^\s+(project|version):/, 'keyword.meta'],
            [/"[^"]*"/, 'string'],
            [/'[^']*'/, 'string'],
            [/#[0-9a-fA-F]{3,8}/, 'number.hex'],
            [/\d+/, 'number'],
            [/#.*$/, 'comment'],
          ]
        }
      });

      monaco.editor.defineTheme('framenote-dark', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: 'keyword', foreground: '58a6ff' },
          { token: 'keyword.template', foreground: 'a855f7' },
          { token: 'keyword.meta', foreground: '3fb950' },
          { token: 'string', foreground: 'ffa657' },
          { token: 'number', foreground: 'ff7b72' },
          { token: 'number.hex', foreground: 'd2a8ff' },
          { token: 'comment', foreground: '8b949e' },
        ],
        colors: {
          'editor.background': '#0f0f0f',
          'editor.foreground': '#e6e6e6',
          'editorLineNumber.foreground': '#666666',
          'editorCursor.foreground': '#58a6ff',
          'editor.selectionBackground': '#264f78',
        }
      });

      // Completion provider - Context-aware snippets + keywords
      monaco.languages.registerCompletionItemProvider('pdl', {
        triggerCharacters: [' ', '\n'],
        provideCompletionItems: function(model, position) {
          const word = model.getWordUntilPosition(position);
          const range = {
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn
          };
          
          const lineContent = model.getLineContent(position.lineNumber);
          const textBefore = model.getValueInRange({
            startLineNumber: 1, startColumn: 1,
            endLineNumber: position.lineNumber, endColumn: position.column
          });
          
          // Context detection
          function getContext() {
            // Ë°åÈ†≠„Åß„Äå- „Äç„ÅÆÂæå„Åã
            if (/^\s*-\s+\w*$/.test(lineContent)) return 'new-slide';
            
            // Ë°åÈ†≠„Åß„Äå- „Äç„ÇíÂÖ•Âäõ„Åó„Çà„ÅÜ„Å®„Åó„Å¶„ÅÑ„Çã„Åã
            if (/^\s*-\s*$/.test(lineContent)) return 'new-slide';
            
            // slides: „ÅÆÂæå„ÅÆÁ©∫Ë°å„Åã
            const lines = textBefore.split('\n');
            const lastNonEmptyLine = lines.slice().reverse().find(l => l.trim().length > 0);
            if (lastNonEmptyLine && /^slides:\s*$/.test(lastNonEmptyLine)) return 'new-slide';
            
            // meta: „ÅÆ‰∏≠„ÅãÔºàslides: „Çà„ÇäÂâçÔºâ
            if (/^meta:/m.test(textBefore)) {
              const afterMeta = textBefore.split(/^meta:/m)[1] || '';
              if (!/^slides:/m.test(afterMeta)) return 'in-meta';
            }
            
            // body: „ÅÆ‰∏≠„ÅãÔºàÁõ¥Ëøë5Ë°å‰ª•ÂÜÖ„Å´body:„Åå„ÅÇ„ÇãÔºâ
            const recentLines = lines.slice(-5).join('\n');
            if (/body:\s*$/m.test(recentLines)) return 'in-body';
            
            // „Éï„Ç°„Ç§„É´ÂÖàÈ†≠„Åæ„Åü„ÅØÁ©∫„ÅÆÁä∂ÊÖã
            if (textBefore.trim() === '' || textBefore.trim() === word.word) return 'file-start';
            
            return 'general';
          }
          
          const context = getContext();
          const suggestions = [];
          
          // Slide snippets (for new-slide context)
          const slideSnippets = [
            {
              label: 'üìÑ slide (basic)',
              insertText: 'title: ${1:Title}\n  body:\n    text:\n      - ${2:Item}',
              detail: 'Basic slide with text'
            },
            {
              label: 'üìÑ slide-figure',
              insertText: 'title: ${1:Title}\n  body:\n    style: figure_caption\n    figure: ${2:image.png}\n    caption: ${3:Caption}',
              detail: 'Slide with figure'
            },
            {
              label: 'üìÑ slide-split',
              insertText: 'title: ${1:Title}\n  body:\n    style: split\n    direction: horizontal\n    ratio: "1:1"\n    left:\n      text:\n        - ${2:Left}\n    right:\n      text:\n        - ${3:Right}',
              detail: 'Split layout slide'
            },
            {
              label: 'üìÑ slide-diagram',
              insertText: 'title: ${1:Title}\n  body:\n    diagram:\n      type: box-arrow\n      direction: horizontal\n      boxes:\n        - ${2:Step 1}\n        - ${3:Step 2}\n        - ${4:Step 3}',
              detail: 'Slide with diagram'
            },
            {
              label: 'üé¨ template: title',
              insertText: 'template: title\n  title: "${1:Presentation Title}"\n  subtitle: "${2:Subtitle}"\n  author: "${3:Author}"\n  date: "${4:2025}"',
              detail: 'Title slide'
            },
            {
              label: 'üìë template: section',
              insertText: 'template: section\n  title: "${1:Section Title}"\n  subtitle: "${2:Subtitle}"',
              detail: 'Section divider'
            },
            {
              label: 'üí¨ template: quote',
              insertText: 'template: quote\n  quote: "${1:Quote text}"\n  author: "${2:Author}"\n  source: "${3:Source}"',
              detail: 'Quote slide'
            },
            {
              label: '‚ùì template: qa',
              insertText: 'template: qa\n  title: "${1:Questions?}"\n  contact: "${2:email@example.com}"',
              detail: 'Q&A slide'
            },
            {
              label: 'üôè template: thanks',
              insertText: 'template: thanks\n  title: "${1:Thank You!}"\n  message: "${2:Message}"\n  contact: "${3:URL}"',
              detail: 'Thanks slide'
            },
            {
              label: 'üìã template: agenda',
              insertText: 'template: agenda\n  title: "${1:Agenda}"\n  items:\n    - "${2:Item 1}"\n    - "${3:Item 2}"\n    - "${4:Item 3}"',
              detail: 'Agenda slide'
            },
            {
              label: '‚öñÔ∏è template: comparison',
              insertText: 'template: comparison\n  title: "${1:Comparison}"\n  left:\n    label: "${2:Before}"\n    items:\n      - "${3:Item}"\n  right:\n    label: "${4:After}"\n    items:\n      - "${5:Item}"',
              detail: 'Comparison slide'
            },
            {
              label: 'üìÖ template: timeline',
              insertText: 'template: timeline\n  title: "${1:Timeline}"\n  events:\n    - date: "${2:Q1}"\n      title: "${3:Phase 1}"\n    - date: "${4:Q2}"\n      title: "${5:Phase 2}"',
              detail: 'Timeline slide'
            },
          ];
          
          // Meta snippet
          const metaSnippet = {
            label: '‚öôÔ∏è meta',
            insertText: 'meta:\n  project: "${1:Project Name}"\n  author: "${2:Author}"\n  date: "${3:2025-01-01}"\n  version: "${4:1.0}"\n  theme: ${5:default}\n  font: ${6:sans}\n\nslides:',
            detail: 'Meta section with slides'
          };
          
          // Header-footer snippet
          const headerFooterSnippet = {
            label: 'üìù header-footer',
            insertText: 'header:\n    show: true\n    text: "{project}"\n    format:\n      color: "#666666"\n      size: 28\nfooter:\n    show: true\n    left: "{author}"\n    right: "{page} / {total}"\n    format:\n      color: "#999999"\n      size: 28',
            detail: 'Header and footer config'
          };
          
          // Format snippet
          const formatSnippet = {
            label: 'üé® format',
            insertText: 'format:\n    accent:\n      color: "${1:#3b82f6}"\n    title:\n      color: "${2:#1a1a1a}"\n      size: ${3:48}\n    bullet:\n      color: "${4:#3b82f6}"',
            detail: 'Format settings'
          };
          
          // Font snippet
          const fontSnippet = {
            label: 'üî§ font',
            insertText: 'font:\n    heading: "${1:Montserrat}"\n    body: "${2:Noto Sans JP}"\n    code: "${3:Fira Code}"',
            detail: 'Custom font settings'
          };
          
          // Diagram snippet
          const diagramSnippet = {
            label: 'üìä diagram',
            insertText: 'diagram:\n      type: box-arrow\n      direction: ${1:horizontal}\n      boxes:\n        - ${2:Step 1}\n        - ${3:Step 2}\n        - ${4:Step 3}',
            detail: 'Diagram block'
          };
          
          // Table snippet
          const tableSnippet = {
            label: 'üìã table',
            insertText: 'table: |\n      | ${1:Header 1} | ${2:Header 2} | ${3:Header 3} |\n      |:------------|:------------:|-------------:|\n      | ${4:Left} | ${5:Center} | ${6:Right} |\n      | ${7:Cell} | ${8:Cell} | ${9:Cell} |\n    tableStyle:\n      colWidths: [200, 250, 150]\n      rowHeight: 52',
            detail: 'Markdown table (with style)'
          };
          
          // Code snippet
          const codeSnippet = {
            label: 'üíª code',
            insertText: 'code:\n      language: ${1|javascript,python,java,rust,go,yaml,sql|}\n      content: |\n        ${2:// Your code here}\n        ${3:console.log("Hello");}\n      style:\n        theme: ${4|dark,light,match|}',
            detail: 'Code block with syntax highlighting'
          };
          
          // Math snippet
          const mathSnippet = {
            label: 'üî¢ math',
            insertText: 'math:\n      - "${1:E = mc^2}"\n      - "${2:F = ma}"\n    mathStyle:\n      fontSize: ${3:42}\n      align: ${4|center,left,right|}',
            detail: 'Math equations (LaTeX/KaTeX)'
          };
          
          // Shapes snippet
          const shapesSnippet = {
            label: 'üî∑ shapes',
            insertText: 'shapes:\n      - type: ${1|rect,circle,ellipse,line,arrow,diamond,triangle,polygon|}\n        x: ${2:400}\n        y: ${3:300}\n        ${4:width: 200}\n        ${5:height: 100}\n        fill: "${6:#6366f1}"\n        label: "${7:Label}"',
            detail: 'SVG shapes drawing'
          };
          
          // Flowchart snippet
          const flowchartSnippet = {
            label: 'üìä flowchart',
            insertText: 'flowchart: |\n      direction: ${1|LR,TB,RL,BT|}\n      ${2:A}[${3:Start}] --> ${4:B}(${5:Process})\n      ${4:B} --> ${6:C}{${7:Decision}}\n      ${6:C} -->|${8:Yes}| ${9:D}[${10:End}]\n      ${6:C} -->|${11:No}| ${4:B}',
            detail: 'Mermaid-style flowchart'
          };
          
          // Sequence diagram snippet
          const sequenceSnippet = {
            label: 'üîÑ sequence',
            insertText: 'sequence: |\n      ${1:Client} ->> ${2:Server}: ${3:Request}\n      ${2:Server} -->> ${1:Client}: ${4:Response}',
            detail: 'Sequence diagram'
          };
          
          // Add snippets based on context
          if (context === 'new-slide') {
            slideSnippets.forEach(s => {
              suggestions.push({
                label: s.label,
                kind: monaco.languages.CompletionItemKind.Snippet,
                insertText: s.insertText,
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                detail: s.detail,
                sortText: '0' + s.label,
                range: range
              });
            });
          }
          
          if (context === 'file-start') {
            suggestions.push({
              label: metaSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: metaSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: metaSnippet.detail,
              sortText: '0',
              range: range
            });
          }
          
          if (context === 'in-meta') {
            [headerFooterSnippet, formatSnippet, fontSnippet].forEach(s => {
              suggestions.push({
                label: s.label,
                kind: monaco.languages.CompletionItemKind.Snippet,
                insertText: s.insertText,
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                detail: s.detail,
                sortText: '0' + s.label,
                range: range
              });
            });
          }
          
          if (context === 'in-body') {
            suggestions.push({
              label: diagramSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: diagramSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: diagramSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: tableSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: tableSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: tableSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: codeSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: codeSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: codeSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: mathSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: mathSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: mathSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: shapesSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: shapesSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: shapesSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: flowchartSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: flowchartSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: flowchartSnippet.detail,
              sortText: '0',
              range: range
            });
            suggestions.push({
              label: sequenceSnippet.label,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: sequenceSnippet.insertText,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              detail: sequenceSnippet.detail,
              sortText: '0',
              range: range
            });
          }
          
          // Keywords with colon (YAML keys) - always available
          const keysWithColon = [
            { label: 'meta:', detail: 'Metadata section' },
            { label: 'slides:', detail: 'Slides array' },
            { label: 'project:', detail: 'Project name' },
            { label: 'author:', detail: 'Author name' },
            { label: 'date:', detail: 'Date' },
            { label: 'version:', detail: 'Version' },
            { label: 'theme:', detail: 'Theme name' },
            { label: 'font:', detail: 'Font preset or settings' },
            { label: 'heading:', detail: 'Heading font family' },
            { label: 'body:', detail: 'Body content' },
            { label: 'code:', detail: 'Code block' },
            { label: 'title:', detail: 'Slide title' },
            { label: 'subtitle:', detail: 'Subtitle' },
            { label: 'template:', detail: 'Template type' },
            { label: 'body:', detail: 'Body content' },
            { label: 'format:', detail: 'Format settings' },
            { label: 'notes:', detail: 'Speaker notes' },
            { label: 'text:', detail: 'Text array' },
            { label: 'style:', detail: 'Layout style' },
            { label: 'figure:', detail: 'Image filename' },
            { label: 'caption:', detail: 'Figure caption' },
            { label: 'diagram:', detail: 'Diagram block' },
            { label: 'table:', detail: 'Markdown table' },
            { label: 'tableStyle:', detail: 'Table style options' },
            { label: 'code:', detail: 'Code block' },
            { label: 'language:', detail: 'Code language' },
            { label: 'content:', detail: 'Code content' },
            { label: 'lineNumbers:', detail: 'Show line numbers' },
            { label: 'style:', detail: 'Code style options' },
            { label: 'theme:', detail: 'Code theme (dark/light)' },
            { label: 'background:', detail: 'Background color' },
            { label: 'math:', detail: 'Math equation (LaTeX)' },
            { label: 'mathStyle:', detail: 'Math style options' },
            { label: 'formula:', detail: 'Math formula' },
            { label: 'align:', detail: 'Alignment' },
            { label: 'lineSpacing:', detail: 'Line spacing for multiple equations' },
            { label: 'shapes:', detail: 'SVG shapes array' },
            { label: 'flowchart:', detail: 'Mermaid-style flowchart' },
            { label: 'sequence:', detail: 'Sequence diagram' },
            { label: 'content:', detail: 'Chart content' },
            { label: 'chart:', detail: 'Chart content (alias)' },
            { label: 'nodeWidth:', detail: 'Flowchart node width' },
            { label: 'nodeHeight:', detail: 'Flowchart node height' },
            { label: 'gapX:', detail: 'Horizontal gap' },
            { label: 'gapY:', detail: 'Vertical gap' },
            { label: 'participantWidth:', detail: 'Sequence participant width' },
            { label: 'participantHeight:', detail: 'Sequence participant height' },
            { label: 'messageGap:', detail: 'Sequence message gap' },
            { label: 'marginX:', detail: 'Horizontal margin' },
            { label: 'type:', detail: 'Shape type' },
            { label: 'x:', detail: 'X position' },
            { label: 'y:', detail: 'Y position' },
            { label: 'x2:', detail: 'End X position (line/arrow)' },
            { label: 'y2:', detail: 'End Y position (line/arrow)' },
            { label: 'width:', detail: 'Width' },
            { label: 'height:', detail: 'Height' },
            { label: 'r:', detail: 'Radius (circle)' },
            { label: 'rx:', detail: 'X radius (ellipse) or corner radius' },
            { label: 'ry:', detail: 'Y radius (ellipse)' },
            { label: 'fill:', detail: 'Fill color' },
            { label: 'stroke:', detail: 'Stroke color' },
            { label: 'strokeWidth:', detail: 'Stroke width' },
            { label: 'opacity:', detail: 'Opacity (0-1)' },
            { label: 'label:', detail: 'Shape label text' },
            { label: 'labelColor:', detail: 'Label text color' },
            { label: 'labelSize:', detail: 'Label font size' },
            { label: 'points:', detail: 'Points for polygon/polyline' },
            { label: 'd:', detail: 'Path data' },
            { label: 'arrow:', detail: 'Show arrow (line)' },
            { label: 'size:', detail: 'Size (diamond)' },
            { label: 'header:', detail: 'Header config' },
            { label: 'footer:', detail: 'Footer config' },
            { label: 'show:', detail: 'Show/hide' },
            { label: 'left:', detail: 'Left content' },
            { label: 'center:', detail: 'Center content' },
            { label: 'right:', detail: 'Right content' },
            { label: 'color:', detail: 'Color value' },
            { label: 'size:', detail: 'Font size' },
            { label: 'weight:', detail: 'Font weight' },
            { label: 'background:', detail: 'Background' },
            { label: 'accent:', detail: 'Accent color' },
            { label: 'bullet:', detail: 'Bullet color' },
            { label: 'headerBg:', detail: 'Table header background' },
            { label: 'headerColor:', detail: 'Table header text color' },
            { label: 'striped:', detail: 'Striped rows' },
            { label: 'border:', detail: 'Show border' },
            { label: 'fontSize:', detail: 'Table font size' },
            { label: 'colWidths:', detail: 'Column widths array' },
            { label: 'rowHeight:', detail: 'Row height in pixels' },
            { label: 'items:', detail: 'List items' },
            { label: 'events:', detail: 'Timeline events' },
            { label: 'contact:', detail: 'Contact info' },
            { label: 'message:', detail: 'Message text' },
            { label: 'source:', detail: 'Quote source' },
            { label: 'quote:', detail: 'Quote text' },
            { label: 'type:', detail: 'Diagram type' },
            { label: 'direction:', detail: 'Direction' },
            { label: 'boxes:', detail: 'Box labels' },
            { label: 'ratio:', detail: 'Split ratio' },
          ];
          
          // Values (no colon)
          const values = [
            { label: 'title', detail: 'Title template' },
            { label: 'section', detail: 'Section template' },
            { label: 'quote', detail: 'Quote template' },
            { label: 'qa', detail: 'Q&A template' },
            { label: 'thanks', detail: 'Thanks template' },
            { label: 'agenda', detail: 'Agenda template' },
            { label: 'comparison', detail: 'Comparison template' },
            { label: 'timeline', detail: 'Timeline template' },
            { label: 'default', detail: 'Default theme' },
            { label: 'corporate', detail: 'Corporate theme' },
            { label: 'minimal', detail: 'Minimal theme' },
            { label: 'dark', detail: 'Dark theme' },
            { label: 'nature', detail: 'Nature theme' },
            { label: 'sunset', detail: 'Sunset theme' },
            { label: 'ocean', detail: 'Ocean theme' },
            { label: 'lavender', detail: 'Lavender theme' },
            { label: 'rose', detail: 'Rose theme' },
            { label: 'midnight', detail: 'Midnight theme' },
            { label: 'sans', detail: 'Gothic font (Noto Sans JP)' },
            { label: 'serif', detail: 'Mincho font (Noto Serif JP)' },
            { label: 'rounded', detail: 'Rounded font (M PLUS Rounded)' },
            { label: 'business', detail: 'Business font (BIZ UDGothic)' },
            { label: 'modern', detail: 'Modern font (Montserrat + Noto)' },
            { label: 'elegant', detail: 'Elegant font (Playfair + Shippori)' },
            { label: 'handwritten', detail: 'Handwritten font (Klee One)' },
            { label: 'figure_caption', detail: 'Figure with caption' },
            { label: 'split', detail: 'Split layout' },
            { label: 'horizontal', detail: 'Horizontal' },
            { label: 'vertical', detail: 'Vertical' },
            { label: 'box-arrow', detail: 'Box arrow diagram' },
            { label: 'javascript', detail: 'JavaScript language' },
            { label: 'python', detail: 'Python language' },
            { label: 'java', detail: 'Java language' },
            { label: 'rust', detail: 'Rust language' },
            { label: 'go', detail: 'Go language' },
            { label: 'yaml', detail: 'YAML language' },
            { label: 'sql', detail: 'SQL language' },
            { label: 'html', detail: 'HTML language' },
            { label: 'css', detail: 'CSS language' },
            { label: 'bash', detail: 'Bash/Shell language' },
            { label: 'dark', detail: 'Dark code theme' },
            { label: 'light', detail: 'Light code theme' },
            { label: 'match', detail: 'Match slide theme colors' },
            { label: 'rect', detail: 'Rectangle shape' },
            { label: 'circle', detail: 'Circle shape' },
            { label: 'ellipse', detail: 'Ellipse shape' },
            { label: 'line', detail: 'Line shape' },
            { label: 'arrow', detail: 'Arrow shape' },
            { label: 'polygon', detail: 'Polygon shape' },
            { label: 'polyline', detail: 'Polyline shape' },
            { label: 'path', detail: 'SVG path shape' },
            { label: 'diamond', detail: 'Diamond shape' },
            { label: 'triangle', detail: 'Triangle shape' },
            { label: 'group', detail: 'Shape group' },
            { label: 'LR', detail: 'Left to Right direction' },
            { label: 'RL', detail: 'Right to Left direction' },
            { label: 'TB', detail: 'Top to Bottom direction' },
            { label: 'BT', detail: 'Bottom to Top direction' },
            { label: 'true', detail: 'Boolean true' },
            { label: 'false', detail: 'Boolean false' },
          ];
          
          keysWithColon.forEach(kw => {
            suggestions.push({
              label: kw.label,
              kind: monaco.languages.CompletionItemKind.Property,
              insertText: kw.label + ' ',
              detail: kw.detail,
              sortText: '1' + kw.label,
              range: range
            });
          });
          
          values.forEach(kw => {
            suggestions.push({
              label: kw.label,
              kind: monaco.languages.CompletionItemKind.Value,
              insertText: kw.label,
              detail: kw.detail,
              sortText: '2' + kw.label,
              range: range
            });
          });
          
          return { suggestions };
        }
      });

      // Create editor
      monacoEditor = monaco.editor.create(document.getElementById('monaco-container'), {
        value: '',
        language: 'pdl',
        theme: 'framenote-dark',
        fontSize: 13,
        fontFamily: "'JetBrains Mono', monospace",
        lineNumbers: 'on',
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        automaticLayout: true,
        tabSize: 2,
        wordWrap: 'on',
        renderWhitespace: 'selection',
        quickSuggestions: true,
        suggestOnTriggerCharacters: true,
        acceptSuggestionOnEnter: 'on',
        tabCompletion: 'onlySnippets',
        snippetSuggestions: 'top',
        suggest: {
          showSnippets: true,
          snippetsPreventQuickSuggestions: false
        }
      });

      monacoEditor.onDidChangeModelContent(() => {
        parseAndRender();
      });

      // Theme selector
      const themeSelect = document.getElementById('theme-select');
      if (themeSelect) {
        themeSelect.addEventListener('change', function(e) {
          e.stopPropagation();
          themeChangedByUI = true;
          currentTheme = this.value;
          parseAndRender();
        });
      }

      // Font selector
      const fontSelect = document.getElementById('font-select');
      if (fontSelect) {
        fontSelect.addEventListener('change', function(e) {
          e.stopPropagation();
          fontChangedByUI = true;
          currentFont = this.value;
          parseAndRender();
        });
      }

      loadSample();
    });

    // Tab switching
    document.querySelectorAll('.editor-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.editor-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.editor-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.querySelector(`[data-content="${tabName}"]`).classList.add('active');
      });
    });

    // Image handling
    const dropzone = document.getElementById('image-dropzone');
    const imageInput = document.getElementById('image-input');

    dropzone.addEventListener('click', () => imageInput.click());
    dropzone.addEventListener('dragover', e => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });
    imageInput.addEventListener('change', e => handleFiles(e.target.files));

    function handleFiles(files) {
      Array.from(files).forEach(file => {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = e => {
            uploadedImages.set(file.name, e.target.result);
            renderImageGrid();
            parseAndRender();
          };
          reader.readAsDataURL(file);
        }
      });
    }

    function renderImageGrid() {
      const grid = document.getElementById('image-grid');
      grid.innerHTML = '';
      uploadedImages.forEach((data, name) => {
        const item = document.createElement('div');
        item.className = 'image-item';
        item.innerHTML = `
          <img src="${data}" alt="${name}">
          <div class="image-item-name">${name}</div>
          <button class="image-item-delete" onclick="deleteImage('${name}')">‚úï</button>
        `;
        item.addEventListener('click', e => {
          if (!e.target.classList.contains('image-item-delete')) {
            navigator.clipboard.writeText(name);
            showNotification('Copied: ' + name, 'success');
          }
        });
        grid.appendChild(item);
      });
    }

    function deleteImage(name) {
      uploadedImages.delete(name);
      renderImageGrid();
      parseAndRender();
    }

    // Parse and render
    function parseAndRender() {
      const content = monacoEditor ? monacoEditor.getValue() : '';
      const errors = [];
      
      try {
        parsedData = jsyaml.load(content);
        
        if (!parsedData || !parsedData.slides || !Array.isArray(parsedData.slides)) {
          errors.push({ type: 'error', message: 'Invalid structure: slides array required' });
        }
        
        // Sync theme selector with meta.theme (only if not changed by UI)
        const themeSelect = document.getElementById('theme-select');
        if (!themeChangedByUI && parsedData?.meta?.theme && THEMES[parsedData.meta.theme]) {
          currentTheme = parsedData.meta.theme;
          if (themeSelect) themeSelect.value = currentTheme;
        }
        
        // Sync font selector with meta.font (only if not changed by UI)
        const fontSelect = document.getElementById('font-select');
        if (!fontChangedByUI && parsedData?.meta?.font) {
          const fontValue = typeof parsedData.meta.font === 'string' ? parsedData.meta.font : null;
          if (fontValue && FONT_PRESETS[fontValue]) {
            currentFont = fontValue;
            if (fontSelect) fontSelect.value = currentFont;
          }
        }
      } catch (e) {
        errors.push({ type: 'error', message: `YAML Error: ${e.message}` });
        parsedData = null;
      }

      renderValidation(errors);
      renderOutline();
      renderSlide();
      
      // Reset UI change flags after rendering
      themeChangedByUI = false;
      fontChangedByUI = false;
    }

    function renderValidation(errors) {
      const list = document.getElementById('validation-list');
      const count = document.getElementById('validation-count');
      
      if (errors.length === 0) {
        list.innerHTML = '<div class="validation-item success">‚úì No errors</div>';
        count.textContent = '‚úì';
      } else {
        list.innerHTML = errors.map(e => 
          `<div class="validation-item ${e.type}">‚óè ${e.message}</div>`
        ).join('');
        count.textContent = `${errors.length} issue(s)`;
      }
    }

    function renderOutline() {
      const list = document.getElementById('outline-list');
      list.innerHTML = '';

      if (!parsedData || !parsedData.slides) return;

      parsedData.slides.forEach((slide, index) => {
        const item = document.createElement('div');
        item.className = 'outline-item' + (index === currentSlide ? ' active' : '');
        
        const template = slide.template || '';
        const title = slide.title || slide.quote?.substring(0, 20) + '...' || `Slide ${index + 1}`;
        
        item.innerHTML = `
          <span class="outline-number">${index + 1}</span>
          <span>${escapeHtml(title.substring(0, 25))}</span>
          ${template ? `<span class="outline-template">${template}</span>` : ''}
        `;
        item.addEventListener('click', () => {
          currentSlide = index;
          renderOutline();
          renderSlide();
        });
        list.appendChild(item);
      });
    }

    function renderSlide() {
      const frame = document.getElementById('slide-frame');
      const pageInfo = document.getElementById('preview-page');

      if (!parsedData || !parsedData.slides || parsedData.slides.length === 0) {
        frame.innerHTML = '<svg viewBox="0 0 1920 1080"><rect fill="#ffffff" width="1920" height="1080"/><text x="960" y="540" text-anchor="middle" fill="#999" font-size="48">No slides</text></svg>';
        pageInfo.textContent = '0 / 0';
        return;
      }

      const total = parsedData.slides.length;
      currentSlide = Math.max(0, Math.min(currentSlide, total - 1));
      pageInfo.textContent = `${currentSlide + 1} / ${total}`;

      const slide = parsedData.slides[currentSlide];
      const meta = parsedData.meta || {};
      const globalFormat = meta.format || {};
      const slideFormat = slide.format || {};
      const format = mergeFormat(globalFormat, slideFormat);

      frame.innerHTML = generateSlideSVG(slide, meta, format, currentSlide + 1, total);
    }

    function mergeFormat(global, local) {
      const result = JSON.parse(JSON.stringify(global));
      for (const key in local) {
        if (typeof local[key] === 'object' && !Array.isArray(local[key])) {
          result[key] = { ...result[key], ...local[key] };
        } else {
          result[key] = local[key];
        }
      }
      return result;
    }

    function generateSlideSVG(slide, meta, format, pageNum, totalPages) {
      const W = 1920, H = 1080;
      
      // Get theme colors (base from theme, can be overridden by format)
      const theme = getThemeColors(meta);
      
      // Get font settings
      const fonts = getFontSettings(meta);
      
      // Merge slide-specific format
      const slideFormat = slide.format || {};
      const colors = {
        background: slideFormat.background?.color || format.background?.color || theme.background,
        accent: slideFormat.accent?.color || format.accent?.color || theme.accent,
        title: slideFormat.title?.color || format.title?.color || theme.title,
        titleSize: slideFormat.title?.size || format.title?.size || theme.titleSize,
        titleWeight: slideFormat.title?.weight || format.title?.weight || theme.titleWeight,
        text: slideFormat.text?.color || format.text?.color || theme.text,
        textSize: slideFormat.text?.size || format.text?.size || theme.textSize,
        bullet: slideFormat.bullet?.color || format.bullet?.color || theme.bullet,
        muted: theme.muted,
        headerBg: theme.headerBg,
        footerBg: theme.footerBg,
        // Font settings
        headingFont: fonts.heading,
        bodyFont: fonts.body,
        codeFont: fonts.code
      };
      
      let svg = `<svg viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">`;
      
      // Background
      svg += `<rect fill="${colors.background}" width="${W}" height="${H}"/>`;

      // Template-based rendering
      if (slide.template) {
        svg += renderTemplate(slide, meta, colors, W, H, pageNum, totalPages);
      } else {
        svg += renderStandardSlide(slide, meta, colors, W, H, pageNum, totalPages);
      }

      // Header
      if (meta.header?.show) {
        svg += renderHeader(meta, colors, W, pageNum, totalPages);
      }

      // Footer
      if (meta.footer?.show) {
        svg += renderFooter(meta, colors, W, H, pageNum, totalPages);
      }

      svg += '</svg>';
      return svg;
    }

    function renderTemplate(slide, meta, colors, W, H, pageNum, totalPages) {
      switch (slide.template) {
        case 'title':
          return renderTitleTemplate(slide, colors, W, H);
        case 'section':
          return renderSectionTemplate(slide, colors, W, H);
        case 'quote':
          return renderQuoteTemplate(slide, colors, W, H);
        case 'qa':
          return renderQATemplate(slide, colors, W, H);
        case 'thanks':
          return renderThanksTemplate(slide, colors, W, H);
        case 'agenda':
          return renderAgendaTemplate(slide, colors, W, H);
        case 'comparison':
          return renderComparisonTemplate(slide, colors, W, H);
        case 'timeline':
          return renderTimelineTemplate(slide, colors, W, H);
        default:
          return renderStandardSlide(slide, meta, colors, W, H, pageNum, totalPages);
      }
    }

    // Title Template
    function renderTitleTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Accent bar
      svg += `<rect x="0" y="${H/2 - 120}" width="8" height="240" fill="${colors.accent}"/>`;
      
      // Title
      svg += `<text x="${W/2}" y="${H/2 - 40}" text-anchor="middle" font-size="72" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.title || '')}</text>`;
      
      // Subtitle
      if (slide.subtitle) {
        svg += `<text x="${W/2}" y="${H/2 + 40}" text-anchor="middle" font-size="36" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.subtitle)}</text>`;
      }
      
      // Author & Date
      let bottomY = H - 120;
      if (slide.author) {
        svg += `<text x="${W/2}" y="${bottomY}" text-anchor="middle" font-size="24" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.author)}</text>`;
        bottomY += 40;
      }
      if (slide.date) {
        svg += `<text x="${W/2}" y="${bottomY}" text-anchor="middle" font-size="20" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.date)}</text>`;
      }
      
      return svg;
    }

    // Section Template
    function renderSectionTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Large accent background
      svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="${colors.accent}" opacity="0.05"/>`;
      svg += `<rect x="${W/2 - 400}" y="${H/2 - 2}" width="800" height="4" fill="${colors.accent}"/>`;
      
      // Title
      svg += `<text x="${W/2}" y="${H/2 - 60}" text-anchor="middle" font-size="64" font-weight="700" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.title || '')}</text>`;
      
      // Subtitle
      if (slide.subtitle) {
        svg += `<text x="${W/2}" y="${H/2 + 60}" text-anchor="middle" font-size="32" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.subtitle)}</text>`;
      }
      
      return svg;
    }

    // Quote Template
    function renderQuoteTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Quote marks
      svg += `<text x="120" y="350" font-size="300" fill="${colors.accent}" opacity="0.15" font-family="Georgia, serif">"</text>`;
      svg += `<text x="${W - 180}" y="${H - 200}" font-size="300" fill="${colors.accent}" opacity="0.15" font-family="Georgia, serif">"</text>`;
      
      // Quote text
      const quote = slide.quote || '';
      const lines = wrapText(quote, 50);
      let y = H/2 - (lines.length * 30);
      lines.forEach(line => {
        svg += `<text x="${W/2}" y="${y}" text-anchor="middle" font-size="48" font-style="italic" fill="${colors.text}" font-family="Georgia, serif">${escapeHtml(line)}</text>`;
        y += 70;
      });
      
      // Author
      if (slide.author) {
        svg += `<text x="${W/2}" y="${H - 180}" text-anchor="middle" font-size="28" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">‚Äî ${escapeHtml(slide.author)}</text>`;
      }
      
      // Source
      if (slide.source) {
        svg += `<text x="${W/2}" y="${H - 130}" text-anchor="middle" font-size="20" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.source)}</text>`;
      }
      
      return svg;
    }

    // Q&A Template
    function renderQATemplate(slide, colors, W, H) {
      let svg = '';
      
      // Large question mark
      svg += `<text x="${W/2}" y="${H/2 - 50}" text-anchor="middle" font-size="400" fill="${colors.accent}" opacity="0.1" font-family="${colors.headingFont}, sans-serif">?</text>`;
      
      // Title
      const title = slide.title || 'Questions?';
      svg += `<text x="${W/2}" y="${H/2}" text-anchor="middle" font-size="72" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(title)}</text>`;
      
      // Contact
      if (slide.contact) {
        svg += `<text x="${W/2}" y="${H/2 + 80}" text-anchor="middle" font-size="28" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.contact)}</text>`;
      }
      
      return svg;
    }

    // Thanks Template
    function renderThanksTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Gradient-like effect
      svg += `<rect x="0" y="${H - 200}" width="${W}" height="200" fill="${colors.accent}" opacity="0.05"/>`;
      
      // Title
      const title = slide.title || 'Thank You!';
      svg += `<text x="${W/2}" y="${H/2 - 40}" text-anchor="middle" font-size="80" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(title)}</text>`;
      
      // Message
      if (slide.message) {
        svg += `<text x="${W/2}" y="${H/2 + 50}" text-anchor="middle" font-size="28" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.message)}</text>`;
      }
      
      // Contact
      if (slide.contact) {
        svg += `<text x="${W/2}" y="${H/2 + 110}" text-anchor="middle" font-size="24" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.contact)}</text>`;
      }
      
      return svg;
    }

    // Agenda Template
    function renderAgendaTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Title
      const title = slide.title || 'Agenda';
      svg += `<text x="120" y="140" font-size="56" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(title)}</text>`;
      svg += `<rect x="120" y="170" width="200" height="4" fill="${colors.accent}"/>`;
      
      // Items
      const items = slide.items || [];
      let y = 280;
      items.forEach((item, i) => {
        // Number circle
        svg += `<circle cx="180" cy="${y - 12}" r="24" fill="${colors.accent}"/>`;
        svg += `<text x="180" y="${y - 6}" text-anchor="middle" font-size="20" font-weight="600" fill="${colors.background}" font-family="${colors.headingFont}, sans-serif">${i + 1}</text>`;
        
        // Item text
        svg += `<text x="230" y="${y}" font-size="32" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(item)}</text>`;
        y += 90;
      });
      
      return svg;
    }

    // Comparison Template
    function renderComparisonTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Title
      if (slide.title) {
        svg += `<text x="${W/2}" y="100" text-anchor="middle" font-size="48" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.title)}</text>`;
      }
      
      const leftX = W * 0.25;
      const rightX = W * 0.75;
      const startY = 200;
      
      // Left side
      if (slide.left) {
        svg += `<rect x="80" y="${startY - 20}" width="${W/2 - 120}" height="${H - startY - 80}" rx="8" fill="${colors.accent}" opacity="0.05"/>`;
        svg += `<text x="${leftX}" y="${startY + 40}" text-anchor="middle" font-size="36" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.left.label || 'Left')}</text>`;
        
        let y = startY + 120;
        (slide.left.items || []).forEach(item => {
          svg += `<text x="${leftX}" y="${y}" text-anchor="middle" font-size="24" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">‚Ä¢ ${escapeHtml(item)}</text>`;
          y += 50;
        });
      }
      
      // Divider
      svg += `<line x1="${W/2}" y1="${startY}" x2="${W/2}" y2="${H - 100}" stroke="${colors.muted}" stroke-width="2" opacity="0.3"/>`;
      
      // Right side
      if (slide.right) {
        svg += `<rect x="${W/2 + 40}" y="${startY - 20}" width="${W/2 - 120}" height="${H - startY - 80}" rx="8" fill="${colors.accent}" opacity="0.1"/>`;
        svg += `<text x="${rightX}" y="${startY + 40}" text-anchor="middle" font-size="36" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.right.label || 'Right')}</text>`;
        
        let y = startY + 120;
        (slide.right.items || []).forEach(item => {
          svg += `<text x="${rightX}" y="${y}" text-anchor="middle" font-size="24" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">‚Ä¢ ${escapeHtml(item)}</text>`;
          y += 50;
        });
      }
      
      return svg;
    }

    // Timeline Template
    function renderTimelineTemplate(slide, colors, W, H) {
      let svg = '';
      
      // Title
      if (slide.title) {
        svg += `<text x="${W/2}" y="100" text-anchor="middle" font-size="48" font-weight="700" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.title)}</text>`;
      }
      
      const events = slide.events || [];
      if (events.length === 0) return svg;
      
      const lineY = H/2 + 50;
      const startX = 200;
      const endX = W - 200;
      const spacing = (endX - startX) / Math.max(events.length - 1, 1);
      
      // Timeline line
      svg += `<line x1="${startX}" y1="${lineY}" x2="${endX}" y2="${lineY}" stroke="${colors.muted}" stroke-width="4" opacity="0.3"/>`;
      
      // Events
      events.forEach((event, i) => {
        const x = events.length === 1 ? W/2 : startX + (i * spacing);
        
        // Circle
        svg += `<circle cx="${x}" cy="${lineY}" r="16" fill="${colors.accent}"/>`;
        svg += `<circle cx="${x}" cy="${lineY}" r="8" fill="${colors.background}"/>`;
        
        // Date (above)
        svg += `<text x="${x}" y="${lineY - 50}" text-anchor="middle" font-size="24" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(event.date || '')}</text>`;
        
        // Title (below)
        const titleLines = wrapText(event.title || '', 15);
        let ty = lineY + 50;
        titleLines.forEach(line => {
          svg += `<text x="${x}" y="${ty}" text-anchor="middle" font-size="20" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(line)}</text>`;
          ty += 28;
        });
      });
      
      return svg;
    }

    // Standard slide rendering
    function renderStandardSlide(slide, meta, colors, W, H, pageNum, totalPages) {
      let svg = '';
      
      // Title
      if (slide.title) {
        svg += `<text x="120" y="120" font-size="${colors.titleSize}" font-weight="${colors.titleWeight}" fill="${colors.title}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(slide.title)}</text>`;
      }
      
      // Body content
      if (slide.body) {
        svg += renderBody(slide.body, colors, W, H);
      }
      
      return svg;
    }

    function renderBody(body, colors, W, H) {
      let svg = '';
      
      const style = body.style || 'text';
      
      switch (style) {
        case 'figure_caption':
        case 'figure_bullets':
          svg += renderFigureLayout(body, colors, W, H);
          break;
        case 'split':
          svg += renderSplitLayout(body, colors, W, H);
          break;
        default:
          svg += renderTextLayout(body, colors, W, H);
      }
      
      // Diagram
      if (body.diagram) {
        svg += renderDiagram(body.diagram, colors, W, H);
      }
      
      // Table (Markdown format)
      if (body.table) {
        svg += renderTable(body.table, body.tableStyle, colors, W, H);
      }
      
      // Code block
      if (body.code) {
        svg += renderCodeBlock(body.code, colors, W, H);
      }
      
      // Math (LaTeX/KaTeX)
      if (body.math) {
        svg += renderMath(body.math, body.mathStyle, colors, W, H);
      }
      
      // Shapes (SVG primitives)
      if (body.shapes) {
        svg += renderShapes(body.shapes, colors, W, H);
      }
      
      // Flowchart (Mermaid-style)
      if (body.flowchart) {
        svg += renderFlowchart(body.flowchart, colors, W, H);
      }
      
      // Sequence diagram
      if (body.sequence) {
        svg += renderSequence(body.sequence, colors, W, H);
      }
      
      return svg;
    }

    // Parse Markdown table
    function parseMarkdownTable(tableStr) {
      const lines = tableStr.trim().split('\n').filter(line => line.trim());
      if (lines.length < 2) return { headers: [], rows: [], aligns: [] };
      
      // Parse headers (first line)
      const headers = lines[0]
        .split('|')
        .map(c => c.trim())
        .filter(c => c.length > 0);
      
      // Parse alignment from separator line (line with |---|---|)
      const aligns = [];
      if (lines.length >= 2) {
        const separatorCells = lines[1].split('|').filter(c => c.trim().length > 0);
        separatorCells.forEach(cell => {
          const trimmed = cell.trim();
          if (trimmed.startsWith(':') && trimmed.endsWith(':')) {
            aligns.push('center');
          } else if (trimmed.endsWith(':')) {
            aligns.push('right');
          } else {
            aligns.push('left');  // default or |:--| or |--|
          }
        });
      }
      
      // Parse data rows
      const rows = [];
      for (let i = 2; i < lines.length; i++) {
        const row = lines[i]
          .split('|')
          .slice(1, -1)  // Remove first and last empty elements
          .map(c => c.trim());
        
        if (row.length > 0) {
          rows.push(row);
        }
      }
      
      return { headers, rows, aligns };
    }

    // Render table as SVG
    function renderTable(tableStr, tableStyle, colors, W, H) {
      let svg = '';
      
      const { headers, rows, aligns } = parseMarkdownTable(tableStr);
      if (headers.length === 0) return svg;
      
      // Style options
      const style = tableStyle || {};
      const headerBg = style.headerBg || colors.accent;
      const headerColor = style.headerColor || colors.background;
      const striped = style.striped !== false;
      const border = style.border !== false;
      const fontSize = style.fontSize || 24;
      const rowHeight = style.rowHeight || 56;
      
      // Calculate column widths based on content length
      const colCount = headers.length;
      const padding = 32;  // padding on each side
      
      // Estimate text width (rough: CJK ~= fontSize, ASCII ~= fontSize * 0.6)
      function estimateTextWidth(text, size) {
        let width = 0;
        for (const char of text) {
          // CJK characters (wider)
          if (/[\u3000-\u9fff\uff00-\uffef]/.test(char)) {
            width += size * 0.9;
          } else {
            width += size * 0.55;
          }
        }
        return width + padding * 2;
      }
      
      // Use custom colWidths if provided, otherwise auto-calculate
      let colWidths;
      if (style.colWidths && Array.isArray(style.colWidths)) {
        // Use provided widths (extend with auto for missing columns)
        colWidths = headers.map((header, colIdx) => {
          if (style.colWidths[colIdx] !== undefined) {
            return style.colWidths[colIdx];
          }
          // Auto-calculate for unspecified columns
          let maxWidth = estimateTextWidth(header, fontSize);
          rows.forEach(row => {
            if (row[colIdx]) {
              const cellWidth = estimateTextWidth(row[colIdx].replace(/\*\*/g, ''), fontSize);
              maxWidth = Math.max(maxWidth, cellWidth);
            }
          });
          return Math.min(400, Math.max(100, maxWidth));
        });
      } else {
        // Auto-calculate all column widths
        colWidths = headers.map((header, colIdx) => {
          let maxWidth = estimateTextWidth(header, fontSize);
          rows.forEach(row => {
            if (row[colIdx]) {
              const cellWidth = estimateTextWidth(row[colIdx].replace(/\*\*/g, ''), fontSize);
              maxWidth = Math.max(maxWidth, cellWidth);
            }
          });
          return Math.min(400, Math.max(100, maxWidth));
        });
      }
      
      // Calculate total table width
      const tableW = colWidths.reduce((sum, w) => sum + w, 0);
      const maxTableW = W - 240;
      
      // Scale down if table is too wide (only for auto-calculated)
      if (!style.colWidths && tableW > maxTableW) {
        const scale = maxTableW / tableW;
        colWidths.forEach((w, i) => colWidths[i] = w * scale);
      }
      
      const finalTableW = colWidths.reduce((sum, w) => sum + w, 0);
      const tableX = (W - finalTableW) / 2;  // Center the table
      const tableY = 200;
      const tableH = rowHeight * (rows.length + 1);
      
      // Table background
      if (border) {
        svg += `<rect x="${tableX}" y="${tableY}" width="${finalTableW}" height="${tableH}" fill="none" stroke="${colors.muted}" stroke-width="1" rx="4"/>`;
      }
      
      // Header row
      svg += `<rect x="${tableX}" y="${tableY}" width="${finalTableW}" height="${rowHeight}" fill="${headerBg}" rx="4"/>`;
      svg += `<rect x="${tableX}" y="${tableY + rowHeight - 4}" width="${finalTableW}" height="4" fill="${headerBg}"/>`;
      
      // Helper to get column X position
      function getColX(colIndex) {
        let x = tableX;
        for (let i = 0; i < colIndex; i++) {
          x += colWidths[i];
        }
        return x;
      }
      
      headers.forEach((header, i) => {
        const cellX = getColX(i);
        const cellW = colWidths[i];
        const textAnchor = 'middle';  // headers always centered
        const textX = cellX + cellW / 2;
        const textY = tableY + rowHeight / 2 + fontSize / 3;
        
        svg += `<text x="${textX}" y="${textY}" text-anchor="${textAnchor}" font-size="${fontSize}" font-weight="600" fill="${headerColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(header)}</text>`;
        
        // Column divider
        if (border && i > 0) {
          svg += `<line x1="${cellX}" y1="${tableY}" x2="${cellX}" y2="${tableY + tableH}" stroke="${colors.muted}" stroke-width="1" opacity="0.3"/>`;
        }
      });
      
      // Data rows
      rows.forEach((row, rowIndex) => {
        const rowY = tableY + rowHeight * (rowIndex + 1);
        
        // Striped background
        if (striped && rowIndex % 2 === 1) {
          svg += `<rect x="${tableX}" y="${rowY}" width="${finalTableW}" height="${rowHeight}" fill="${colors.accent}" opacity="0.05"/>`;
        }
        
        // Row divider
        if (border) {
          svg += `<line x1="${tableX}" y1="${rowY}" x2="${tableX + finalTableW}" y2="${rowY}" stroke="${colors.muted}" stroke-width="1" opacity="0.3"/>`;
        }
        
        row.forEach((cell, colIndex) => {
          const cellX = getColX(colIndex);
          const cellW = colWidths[colIndex] || 100;
          const align = aligns[colIndex] || 'left';
          
          // Calculate text position based on alignment
          let textX, textAnchor;
          const cellPadding = 16;
          if (align === 'center') {
            textX = cellX + cellW / 2;
            textAnchor = 'middle';
          } else if (align === 'right') {
            textX = cellX + cellW - cellPadding;
            textAnchor = 'end';
          } else {  // left
            textX = cellX + cellPadding;
            textAnchor = 'start';
          }
          
          const textY = rowY + rowHeight / 2 + fontSize / 3;
          
          // Remove ** for bold (we'll render all text the same for now)
          const cleanCell = cell.replace(/\*\*/g, '');
          
          svg += `<text x="${textX}" y="${textY}" text-anchor="${textAnchor}" font-size="${fontSize}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(cleanCell)}</text>`;
        });
      });
      
      return svg;
    }

    // Render code block with syntax highlighting
    function renderCodeBlock(codeConfig, colors, W, H) {
      let svg = '';
      
      const content = typeof codeConfig === 'string' ? codeConfig : codeConfig.content || '';
      const language = codeConfig.language || 'text';
      const showLineNumbers = codeConfig.lineNumbers !== false;
      const fontSize = codeConfig.fontSize || 20;
      const lineHeight = fontSize * 1.5;
      
      // Code style options
      const codeStyle = codeConfig.style || {};
      
      // Code block dimensions
      const codeX = 120;
      const codeY = 200;
      const codeW = W - 240;
      const padding = 24;
      
      // Split into lines
      const lines = content.split('\n');
      const codeH = Math.max(lines.length * lineHeight + padding * 2, 100);
      
      // Helper: darken/lighten a hex color
      function adjustColor(hex, amount) {
        hex = hex.replace('#', '');
        const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
        const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
        const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
        return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
      }
      
      // Helper: blend two colors
      function blendColors(color1, color2, ratio) {
        const hex1 = color1.replace('#', '');
        const hex2 = color2.replace('#', '');
        const r = Math.round(parseInt(hex1.substr(0, 2), 16) * (1 - ratio) + parseInt(hex2.substr(0, 2), 16) * ratio);
        const g = Math.round(parseInt(hex1.substr(2, 2), 16) * (1 - ratio) + parseInt(hex2.substr(2, 2), 16) * ratio);
        const b = Math.round(parseInt(hex1.substr(4, 2), 16) * (1 - ratio) + parseInt(hex2.substr(4, 2), 16) * ratio);
        return '#' + [r, g, b].map(c => Math.max(0, Math.min(255, c)).toString(16).padStart(2, '0')).join('');
      }
      
      // Helper: get brightness
      function getBrightness(hex) {
        hex = hex.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        return (r * 299 + g * 587 + b * 114) / 1000;
      }
      
      // Background color - customizable or auto-detect based on theme
      let bgColor, textColor, syntaxColors;
      const themeBg = colors.background;
      const themeAccent = colors.accent;
      const isLightTheme = getBrightness(themeBg) > 128;
      
      if (codeStyle.theme === 'match') {
        // Match theme colors - use accent-tinted background
        if (isLightTheme) {
          bgColor = blendColors(themeBg, themeAccent, 0.08);
          bgColor = adjustColor(bgColor, -30);  // slightly darker
          textColor = adjustColor(themeBg, -180);
        } else {
          bgColor = blendColors(themeBg, themeAccent, 0.15);
          bgColor = adjustColor(bgColor, -20);
          textColor = adjustColor(themeBg, 180);
        }
        
        // Theme-based syntax colors
        const accentBright = adjustColor(themeAccent, 40);
        const accentDark = adjustColor(themeAccent, -40);
        syntaxColors = {
          keyword: themeAccent,
          string: isLightTheme ? '#16a34a' : '#a3e635',
          number: isLightTheme ? '#ea580c' : '#fb923c',
          comment: blendColors(textColor, bgColor, 0.5),
          function: accentBright,
          operator: isLightTheme ? accentDark : accentBright,
          default: textColor
        };
      } else if (codeStyle.background) {
        bgColor = codeStyle.background;
        const brightness = getBrightness(bgColor);
        textColor = brightness > 128 ? '#1e293b' : '#e0e0e0';
        syntaxColors = null;  // will set below
      } else if (codeStyle.theme === 'light') {
        bgColor = '#f8fafc';
        textColor = '#1e293b';
        syntaxColors = null;
      } else if (codeStyle.theme === 'dark') {
        bgColor = '#1e293b';
        textColor = '#e0e0e0';
        syntaxColors = null;
      } else {
        // Auto: dark code block for light themes, darker for dark themes
        bgColor = isLightTheme ? '#1e293b' : '#0f172a';
        textColor = '#e0e0e0';
        syntaxColors = null;
      }
      
      // Default syntax colors if not set
      if (!syntaxColors) {
        const isDarkBg = getBrightness(bgColor) < 128;
        syntaxColors = isDarkBg ? {
          keyword: '#c792ea',
          string: '#c3e88d',
          number: '#f78c6c',
          comment: '#546e7a',
          function: '#82aaff',
          operator: '#89ddff',
          default: textColor
        } : {
          keyword: '#7c3aed',
          string: '#16a34a',
          number: '#ea580c',
          comment: '#64748b',
          function: '#2563eb',
          operator: '#0891b2',
          default: textColor
        };
      }
      
      svg += `<rect x="${codeX}" y="${codeY}" width="${codeW}" height="${codeH}" rx="8" fill="${bgColor}"/>`;
      
      // Language badge
      if (language && language !== 'text') {
        svg += `<rect x="${codeX + codeW - 100}" y="${codeY}" width="100" height="28" rx="0 8 0 8" fill="${colors.accent}" opacity="0.8"/>`;
        svg += `<text x="${codeX + codeW - 50}" y="${codeY + 19}" text-anchor="middle" font-size="12" fill="#ffffff" font-family="${colors.headingFont}, sans-serif">${escapeHtml(language)}</text>`;
      }
      
      // Language-specific keywords
      const keywords = {
        javascript: ['const', 'let', 'var', 'function', 'return', 'if', 'else', 'for', 'while', 'class', 'import', 'export', 'from', 'async', 'await', 'try', 'catch', 'throw', 'new', 'this', 'true', 'false', 'null', 'undefined'],
        python: ['def', 'class', 'return', 'if', 'elif', 'else', 'for', 'while', 'import', 'from', 'as', 'try', 'except', 'raise', 'with', 'lambda', 'True', 'False', 'None', 'and', 'or', 'not', 'in', 'is', 'pass', 'break', 'continue'],
        java: ['public', 'private', 'protected', 'class', 'interface', 'extends', 'implements', 'return', 'if', 'else', 'for', 'while', 'try', 'catch', 'throw', 'new', 'this', 'static', 'final', 'void', 'int', 'boolean', 'String', 'true', 'false', 'null'],
        rust: ['fn', 'let', 'mut', 'const', 'struct', 'enum', 'impl', 'trait', 'pub', 'use', 'mod', 'if', 'else', 'match', 'loop', 'while', 'for', 'in', 'return', 'self', 'Self', 'true', 'false', 'Some', 'None', 'Ok', 'Err'],
        go: ['func', 'var', 'const', 'type', 'struct', 'interface', 'package', 'import', 'return', 'if', 'else', 'for', 'range', 'switch', 'case', 'default', 'go', 'chan', 'defer', 'true', 'false', 'nil'],
        yaml: ['true', 'false', 'null', 'yes', 'no'],
        sql: ['SELECT', 'FROM', 'WHERE', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'TABLE', 'INDEX', 'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER', 'ON', 'AND', 'OR', 'NOT', 'NULL', 'ORDER', 'BY', 'GROUP', 'HAVING', 'LIMIT', 'OFFSET', 'AS'],
      };
      
      const langKeywords = keywords[language] || keywords['javascript'] || [];
      
      // Tokenize and highlight a line
      function highlightLine(line) {
        const tokens = [];
        let remaining = line;
        
        while (remaining.length > 0) {
          let matched = false;
          
          // Comment (// or #)
          if (/^(\/\/.*|#.*)/.test(remaining)) {
            const match = remaining.match(/^(\/\/.*|#.*)/)[0];
            tokens.push({ text: match, color: syntaxColors.comment });
            remaining = remaining.slice(match.length);
            matched = true;
          }
          // String (single or double quotes)
          else if (/^(["'`])/.test(remaining)) {
            const quote = remaining[0];
            const regex = new RegExp(`^${quote}[^${quote}]*${quote}`);
            const match = remaining.match(regex);
            if (match) {
              tokens.push({ text: match[0], color: syntaxColors.string });
              remaining = remaining.slice(match[0].length);
              matched = true;
            }
          }
          // Number
          else if (/^-?\d+\.?\d*/.test(remaining)) {
            const match = remaining.match(/^-?\d+\.?\d*/)[0];
            tokens.push({ text: match, color: syntaxColors.number });
            remaining = remaining.slice(match.length);
            matched = true;
          }
          // Keyword or identifier
          else if (/^[a-zA-Z_]\w*/.test(remaining)) {
            const match = remaining.match(/^[a-zA-Z_]\w*/)[0];
            if (langKeywords.includes(match)) {
              tokens.push({ text: match, color: syntaxColors.keyword });
            } else if (/^[A-Z]/.test(match)) {
              tokens.push({ text: match, color: syntaxColors.function });
            } else {
              tokens.push({ text: match, color: syntaxColors.default });
            }
            remaining = remaining.slice(match.length);
            matched = true;
          }
          // Operator
          else if (/^[+\-*/%=<>!&|^~?:]+/.test(remaining)) {
            const match = remaining.match(/^[+\-*/%=<>!&|^~?:]+/)[0];
            tokens.push({ text: match, color: syntaxColors.operator });
            remaining = remaining.slice(match.length);
            matched = true;
          }
          
          // Default: single character
          if (!matched) {
            tokens.push({ text: remaining[0], color: syntaxColors.default });
            remaining = remaining.slice(1);
          }
        }
        
        return tokens;
      }
      
      // Render lines
      const lineNumWidth = showLineNumbers ? 50 : 0;
      let y = codeY + padding + fontSize;
      
      lines.forEach((line, i) => {
        // Line number
        if (showLineNumbers) {
          svg += `<text x="${codeX + padding + 30}" y="${y}" text-anchor="end" font-size="${fontSize}" fill="${syntaxColors.comment}" font-family="${colors.codeFont}, monospace">${i + 1}</text>`;
        }
        
        // Code line with highlighting
        const tokens = highlightLine(line);
        let x = codeX + padding + lineNumWidth + 10;
        
        tokens.forEach(token => {
          svg += `<text x="${x}" y="${y}" font-size="${fontSize}" fill="${token.color}" font-family="${colors.codeFont}, monospace">${escapeHtml(token.text)}</text>`;
          // Estimate character width for monospace font
          x += token.text.length * fontSize * 0.6;
        });
        
        y += lineHeight;
      });
      
      return svg;
    }

    // Render math equation using KaTeX
    function renderMath(mathConfig, mathStyle, colors, W, H) {
      let svg = '';
      
      const style = mathStyle || {};
      const fontSize = style.fontSize || 36;
      const align = style.align || 'center';
      const lineSpacing = style.lineSpacing || 1.2;
      
      // Support both single formula and array of formulas
      let formulas = [];
      if (typeof mathConfig === 'string') {
        formulas = [mathConfig];
      } else if (Array.isArray(mathConfig)) {
        formulas = mathConfig;
      } else if (mathConfig.formula) {
        formulas = Array.isArray(mathConfig.formula) ? mathConfig.formula : [mathConfig.formula];
      }
      
      // Calculate alignment
      let textAnchor;
      let mathX;
      if (align === 'left') {
        mathX = 120;
        textAnchor = 'start';
      } else if (align === 'right') {
        mathX = W - 120;
        textAnchor = 'end';
      } else {
        mathX = W / 2;
        textAnchor = 'middle';
      }
      
      // Starting Y position
      let currentY = 200;
      const foreignWidth = W - 240;
      const foreignX = (W - foreignWidth) / 2;
      
      formulas.forEach((formula, index) => {
        // Detect multiline formulas
        const isMultiline = formula.includes('\\begin{') || formula.includes('\\\\') || formula.split('\n').length > 1;
        
        // Calculate height based on fontSize and content type
        const baseHeight = fontSize * 3;  // Base height proportional to font size
        const formulaHeight = isMultiline ? Math.max(baseHeight * 3, 300) : Math.max(baseHeight, 120);
        
        // Check if KaTeX is available
        if (typeof katex !== 'undefined') {
          try {
            // Render to HTML string
            const mathHtml = katex.renderToString(formula, {
              displayMode: true,
              throwOnError: false,
              output: 'html'
            });
            
            svg += `<foreignObject x="${foreignX}" y="${currentY}" width="${foreignWidth}" height="${formulaHeight}">
              <div xmlns="http://www.w3.org/1999/xhtml" style="
                display: flex;
                justify-content: ${align === 'left' ? 'flex-start' : align === 'right' ? 'flex-end' : 'center'};
                align-items: flex-start;
                width: 100%;
                height: 100%;
              ">
                <div style="font-size: ${fontSize}px; color: ${colors.text};">
                  ${mathHtml}
                </div>
              </div>
            </foreignObject>`;
          } catch (e) {
            // Fallback to text display
            svg += renderMathAsText(formula, mathX, currentY + fontSize, textAnchor, fontSize, colors);
          }
        } else {
          // KaTeX not loaded - display as formatted text
          svg += renderMathAsText(formula, mathX, currentY + fontSize, textAnchor, fontSize, colors);
        }
        
        // Move to next line - spacing based on fontSize
        currentY += fontSize * 2 * lineSpacing;
      });
      
      return svg;
    }
    
    // Render math as formatted text (fallback)
    function renderMathAsText(formula, x, y, anchor, fontSize, colors) {
      let svg = '';
      
      // Simple parsing for common LaTeX patterns
      let display = formula
        // Fractions
        .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)')
        // Roots
        .replace(/\\sqrt\{([^}]+)\}/g, '‚àö($1)')
        .replace(/\\sqrt/g, '‚àö')
        // Brackets
        .replace(/\\left\(/g, '(')
        .replace(/\\right\)/g, ')')
        .replace(/\\left\[/g, '[')
        .replace(/\\right\]/g, ']')
        .replace(/\\left\{/g, '{')
        .replace(/\\right\}/g, '}')
        .replace(/\\left\|/g, '|')
        .replace(/\\right\|/g, '|')
        .replace(/\\left\./g, '')
        .replace(/\\right\./g, '')
        // Trigonometric functions
        .replace(/\\sin/g, 'sin')
        .replace(/\\cos/g, 'cos')
        .replace(/\\tan/g, 'tan')
        .replace(/\\cot/g, 'cot')
        .replace(/\\sec/g, 'sec')
        .replace(/\\csc/g, 'csc')
        .replace(/\\arcsin/g, 'arcsin')
        .replace(/\\arccos/g, 'arccos')
        .replace(/\\arctan/g, 'arctan')
        .replace(/\\sinh/g, 'sinh')
        .replace(/\\cosh/g, 'cosh')
        .replace(/\\tanh/g, 'tanh')
        // Other functions
        .replace(/\\log/g, 'log')
        .replace(/\\ln/g, 'ln')
        .replace(/\\exp/g, 'exp')
        .replace(/\\lim/g, 'lim')
        .replace(/\\max/g, 'max')
        .replace(/\\min/g, 'min')
        // Operators
        .replace(/\\pm/g, '¬±')
        .replace(/\\mp/g, '‚àì')
        .replace(/\\times/g, '√ó')
        .replace(/\\div/g, '√∑')
        .replace(/\\cdot/g, '¬∑')
        .replace(/\\ast/g, '‚àó')
        .replace(/\\star/g, '‚ãÜ')
        // Relations
        .replace(/\\leq/g, '‚â§')
        .replace(/\\geq/g, '‚â•')
        .replace(/\\neq/g, '‚â†')
        .replace(/\\approx/g, '‚âà')
        .replace(/\\equiv/g, '‚â°')
        .replace(/\\sim/g, '‚àº')
        .replace(/\\propto/g, '‚àù')
        .replace(/\\ll/g, '‚â™')
        .replace(/\\gg/g, '‚â´')
        // Greek letters (lowercase)
        .replace(/\\alpha/g, 'Œ±')
        .replace(/\\beta/g, 'Œ≤')
        .replace(/\\gamma/g, 'Œ≥')
        .replace(/\\delta/g, 'Œ¥')
        .replace(/\\epsilon/g, 'Œµ')
        .replace(/\\varepsilon/g, 'Œµ')
        .replace(/\\zeta/g, 'Œ∂')
        .replace(/\\eta/g, 'Œ∑')
        .replace(/\\theta/g, 'Œ∏')
        .replace(/\\vartheta/g, 'œë')
        .replace(/\\iota/g, 'Œπ')
        .replace(/\\kappa/g, 'Œ∫')
        .replace(/\\lambda/g, 'Œª')
        .replace(/\\mu/g, 'Œº')
        .replace(/\\nu/g, 'ŒΩ')
        .replace(/\\xi/g, 'Œæ')
        .replace(/\\pi/g, 'œÄ')
        .replace(/\\rho/g, 'œÅ')
        .replace(/\\sigma/g, 'œÉ')
        .replace(/\\tau/g, 'œÑ')
        .replace(/\\upsilon/g, 'œÖ')
        .replace(/\\phi/g, 'œÜ')
        .replace(/\\varphi/g, 'œï')
        .replace(/\\chi/g, 'œá')
        .replace(/\\psi/g, 'œà')
        .replace(/\\omega/g, 'œâ')
        // Greek letters (uppercase)
        .replace(/\\Gamma/g, 'Œì')
        .replace(/\\Delta/g, 'Œî')
        .replace(/\\Theta/g, 'Œò')
        .replace(/\\Lambda/g, 'Œõ')
        .replace(/\\Xi/g, 'Œû')
        .replace(/\\Pi/g, 'Œ†')
        .replace(/\\Sigma/g, 'Œ£')
        .replace(/\\Phi/g, 'Œ¶')
        .replace(/\\Psi/g, 'Œ®')
        .replace(/\\Omega/g, 'Œ©')
        // Big operators
        .replace(/\\sum/g, 'Œ£')
        .replace(/\\prod/g, 'Œ†')
        .replace(/\\int/g, '‚à´')
        .replace(/\\iint/g, '‚à¨')
        .replace(/\\iiint/g, '‚à≠')
        .replace(/\\oint/g, '‚àÆ')
        // Misc symbols
        .replace(/\\infty/g, '‚àû')
        .replace(/\\partial/g, '‚àÇ')
        .replace(/\\nabla/g, '‚àá')
        .replace(/\\forall/g, '‚àÄ')
        .replace(/\\exists/g, '‚àÉ')
        .replace(/\\in/g, '‚àà')
        .replace(/\\notin/g, '‚àâ')
        .replace(/\\subset/g, '‚äÇ')
        .replace(/\\supset/g, '‚äÉ')
        .replace(/\\cup/g, '‚à™')
        .replace(/\\cap/g, '‚à©')
        .replace(/\\emptyset/g, '‚àÖ')
        .replace(/\\ldots/g, '‚Ä¶')
        .replace(/\\cdots/g, '‚ãØ')
        .replace(/\\vdots/g, '‚ãÆ')
        .replace(/\\ddots/g, '‚ã±')
        // Arrows
        .replace(/\\rightarrow/g, '‚Üí')
        .replace(/\\leftarrow/g, '‚Üê')
        .replace(/\\leftrightarrow/g, '‚Üî')
        .replace(/\\Rightarrow/g, '‚áí')
        .replace(/\\Leftarrow/g, '‚áê')
        .replace(/\\Leftrightarrow/g, '‚áî')
        .replace(/\\to/g, '‚Üí')
        .replace(/\\mapsto/g, '‚Ü¶')
        // Superscripts and subscripts
        .replace(/\^(\d)/g, (_, d) => '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ'[d])
        .replace(/\^{(\d+)}/g, (_, num) => num.split('').map(d => '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ'[d]).join(''))
        .replace(/\^{n}/g, '‚Åø')
        .replace(/\^{i}/g, '‚Å±')
        .replace(/\^{-1}/g, '‚Åª¬π')
        .replace(/\^{-}/g, '‚Åª')
        .replace(/\^{\\prime}/g, '‚Ä≤')
        .replace(/_(\d)/g, (_, d) => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d])
        .replace(/_{(\d+)}/g, (_, num) => num.split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join(''))
        .replace(/_{i}/g, '·µ¢')
        .replace(/_{j}/g, '‚±º')
        .replace(/_{n}/g, '‚Çô')
        .replace(/_{x}/g, '‚Çì')
        // Spacing
        .replace(/\\quad/g, '  ')
        .replace(/\\qquad/g, '    ')
        .replace(/\\,/g, ' ')
        .replace(/\\;/g, ' ')
        .replace(/\\!/g, '')
        // Text mode
        .replace(/\\text\{([^}]+)\}/g, '$1')
        .replace(/\\mathrm\{([^}]+)\}/g, '$1')
        .replace(/\\mathbf\{([^}]+)\}/g, '$1')
        // Cleanup remaining braces and backslashes
        .replace(/\{|\}/g, '')
        .replace(/\\/g, '');
      
      svg += `<text x="${x}" y="${y}" text-anchor="${anchor}" font-size="${fontSize}" fill="${colors.text}" font-family="Times New Roman, serif" font-style="italic">${escapeHtml(display)}</text>`;
      
      return svg;
    }

    // Render shapes (SVG primitives)
    function renderShapes(shapes, colors, W, H) {
      let svg = '';
      
      // Arrow marker definition
      svg += `<defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="${colors.accent}"/>
        </marker>
        <marker id="arrowhead-text" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="${colors.text}"/>
        </marker>
      </defs>`;
      
      shapes.forEach(shape => {
        const type = shape.type || 'rect';
        const x = shape.x || 0;
        const y = shape.y || 0;
        const fill = shape.fill || colors.accent;
        const stroke = shape.stroke || 'none';
        const strokeWidth = shape.strokeWidth || 2;
        const opacity = shape.opacity !== undefined ? shape.opacity : 1;
        const label = shape.label || '';
        const labelColor = shape.labelColor || colors.background;
        const labelSize = shape.labelSize || 24;
        
        switch (type) {
          case 'rect': {
            const width = shape.width || 200;
            const height = shape.height || 100;
            const rx = shape.rx || 0;
            svg += `<rect x="${x}" y="${y}" width="${width}" height="${height}" rx="${rx}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            if (label) {
              svg += `<text x="${x + width/2}" y="${y + height/2 + labelSize/3}" text-anchor="middle" font-size="${labelSize}" fill="${labelColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'circle': {
            const r = shape.r || 50;
            svg += `<circle cx="${x}" cy="${y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            if (label) {
              svg += `<text x="${x}" y="${y + labelSize/3}" text-anchor="middle" font-size="${labelSize}" fill="${labelColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'ellipse': {
            const rx = shape.rx || 100;
            const ry = shape.ry || 50;
            svg += `<ellipse cx="${x}" cy="${y}" rx="${rx}" ry="${ry}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            if (label) {
              svg += `<text x="${x}" y="${y + labelSize/3}" text-anchor="middle" font-size="${labelSize}" fill="${labelColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'line': {
            const x2 = shape.x2 || x + 100;
            const y2 = shape.y2 || y;
            const lineStroke = stroke !== 'none' ? stroke : colors.text;
            const arrow = shape.arrow || false;
            svg += `<line x1="${x}" y1="${y}" x2="${x2}" y2="${y2}" stroke="${lineStroke}" stroke-width="${strokeWidth}" ${arrow ? 'marker-end="url(#arrowhead-text)"' : ''}/>`;
            break;
          }
          
          case 'arrow': {
            const x2 = shape.x2 || x + 100;
            const y2 = shape.y2 || y;
            const arrowStroke = stroke !== 'none' ? stroke : colors.accent;
            svg += `<line x1="${x}" y1="${y}" x2="${x2}" y2="${y2}" stroke="${arrowStroke}" stroke-width="${strokeWidth}" marker-end="url(#arrowhead)"/>`;
            if (label) {
              const midX = (x + x2) / 2;
              const midY = (y + y2) / 2 - 10;
              svg += `<text x="${midX}" y="${midY}" text-anchor="middle" font-size="${labelSize}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'polygon': {
            const points = shape.points || '0,0 100,0 50,100';
            svg += `<polygon points="${points}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            break;
          }
          
          case 'polyline': {
            const points = shape.points || '0,0 50,50 100,0';
            const lineStroke = stroke !== 'none' ? stroke : colors.accent;
            svg += `<polyline points="${points}" fill="none" stroke="${lineStroke}" stroke-width="${strokeWidth}"/>`;
            break;
          }
          
          case 'path': {
            const d = shape.d || '';
            const pathStroke = stroke !== 'none' ? stroke : colors.accent;
            svg += `<path d="${d}" fill="${fill}" stroke="${pathStroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            break;
          }
          
          case 'text': {
            const fontSize = shape.fontSize || 28;
            const anchor = shape.anchor || 'start';
            const textFill = fill !== colors.accent ? fill : colors.text;
            svg += `<text x="${x}" y="${y}" text-anchor="${anchor}" font-size="${fontSize}" fill="${textFill}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            break;
          }
          
          case 'diamond': {
            const size = shape.size || 100;
            const cx = x;
            const cy = y;
            const points = `${cx},${cy-size/2} ${cx+size/2},${cy} ${cx},${cy+size/2} ${cx-size/2},${cy}`;
            svg += `<polygon points="${points}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            if (label) {
              svg += `<text x="${cx}" y="${cy + labelSize/3}" text-anchor="middle" font-size="${labelSize}" fill="${labelColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'triangle': {
            const width = shape.width || 100;
            const height = shape.height || 100;
            const points = `${x},${y+height} ${x+width/2},${y} ${x+width},${y+height}`;
            svg += `<polygon points="${points}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" opacity="${opacity}"/>`;
            if (label) {
              svg += `<text x="${x + width/2}" y="${y + height*0.7}" text-anchor="middle" font-size="${labelSize}" fill="${labelColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(label)}</text>`;
            }
            break;
          }
          
          case 'group': {
            // Recursive group rendering with transform
            const transform = shape.transform || '';
            svg += `<g transform="${transform}">`;
            if (shape.children && Array.isArray(shape.children)) {
              svg += renderShapes(shape.children, colors, W, H);
            }
            svg += `</g>`;
            break;
          }
        }
      });
      
      return svg;
    }

    function renderTextLayout(body, colors, W, H) {
      let svg = '';
      
      let y = 220;
      const text = body.text;
      
      if (typeof text === 'string') {
        const lines = wrapText(text, 70);
        lines.forEach(line => {
          svg += renderTextWithInlineMath(line, 120, y, colors, 'start');
          y += 50;
        });
      } else if (Array.isArray(text)) {
        text.forEach(item => {
          svg += `<circle cx="140" cy="${y - 10}" r="6" fill="${colors.bullet}"/>`;
          svg += renderTextWithInlineMath(item, 170, y, colors, 'start');
          y += 60;
        });
      }
      
      return svg;
    }
    
    // Render text with inline math ($...$)
    function renderTextWithInlineMath(text, x, y, colors, anchor) {
      // Check if text contains inline math
      if (!text.includes('$')) {
        return `<text x="${x}" y="${y}" text-anchor="${anchor}" font-size="${colors.textSize}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(text)}</text>`;
      }
      
      // Split text by $...$ patterns
      const parts = [];
      let remaining = text;
      let match;
      const mathRegex = /\$([^$]+)\$/g;
      let lastIndex = 0;
      
      while ((match = mathRegex.exec(text)) !== null) {
        // Text before math
        if (match.index > lastIndex) {
          parts.push({ type: 'text', content: text.substring(lastIndex, match.index) });
        }
        // Math content
        parts.push({ type: 'math', content: match[1] });
        lastIndex = match.index + match[0].length;
      }
      // Remaining text
      if (lastIndex < text.length) {
        parts.push({ type: 'text', content: text.substring(lastIndex) });
      }
      
      // If KaTeX is available, use foreignObject
      if (typeof katex !== 'undefined') {
        let html = '';
        parts.forEach(part => {
          if (part.type === 'math') {
            try {
              html += katex.renderToString(part.content, {
                displayMode: false,
                throwOnError: false
              });
            } catch (e) {
              html += `<span style="color: red;">${escapeHtml(part.content)}</span>`;
            }
          } else {
            html += escapeHtml(part.content);
          }
        });
        
        return `<foreignObject x="${x}" y="${y - colors.textSize * 0.8}" width="${1600 - x - 100}" height="${colors.textSize * 2}">
          <div xmlns="http://www.w3.org/1999/xhtml" style="
            font-size: ${colors.textSize}px;
            color: ${colors.text};
            font-family: ${colors.bodyFont}, sans-serif;
            white-space: nowrap;
          ">${html}</div>
        </foreignObject>`;
      } else {
        // Fallback: convert math to Unicode
        let display = text;
        parts.forEach(part => {
          if (part.type === 'math') {
            const converted = convertMathToUnicode(part.content);
            display = display.replace('$' + part.content + '$', converted);
          }
        });
        return `<text x="${x}" y="${y}" text-anchor="${anchor}" font-size="${colors.textSize}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(display)}</text>`;
      }
    }
    
    // Convert simple LaTeX math to Unicode (for fallback)
    function convertMathToUnicode(formula) {
      return formula
        .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)')
        .replace(/\\sqrt\{([^}]+)\}/g, '‚àö($1)')
        .replace(/\\sqrt/g, '‚àö')
        .replace(/\\pm/g, '¬±')
        .replace(/\\times/g, '√ó')
        .replace(/\\div/g, '√∑')
        .replace(/\\cdot/g, '¬∑')
        .replace(/\\leq/g, '‚â§')
        .replace(/\\geq/g, '‚â•')
        .replace(/\\neq/g, '‚â†')
        .replace(/\\approx/g, '‚âà')
        .replace(/\\infty/g, '‚àû')
        .replace(/\\alpha/g, 'Œ±')
        .replace(/\\beta/g, 'Œ≤')
        .replace(/\\gamma/g, 'Œ≥')
        .replace(/\\delta/g, 'Œ¥')
        .replace(/\\theta/g, 'Œ∏')
        .replace(/\\lambda/g, 'Œª')
        .replace(/\\mu/g, 'Œº')
        .replace(/\\pi/g, 'œÄ')
        .replace(/\\sigma/g, 'œÉ')
        .replace(/\\phi/g, 'œÜ')
        .replace(/\\omega/g, 'œâ')
        .replace(/\\sum/g, 'Œ£')
        .replace(/\\int/g, '‚à´')
        .replace(/\\partial/g, '‚àÇ')
        .replace(/\\rightarrow/g, '‚Üí')
        .replace(/\\Rightarrow/g, '‚áí')
        .replace(/\^(\d)/g, (_, d) => '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ'[d])
        .replace(/\^{(\d+)}/g, (_, num) => num.split('').map(d => '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ'[d]).join(''))
        .replace(/_(\d)/g, (_, d) => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d])
        .replace(/_{(\d+)}/g, (_, num) => num.split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join(''))
        .replace(/\{|\}/g, '')
        .replace(/\\/g, '');
    }

    function renderFigureLayout(body, colors, W, H) {
      let svg = '';
      
      // Figure
      if (body.figure) {
        const imgSrc = getImageSrc(body.figure);
        const imgW = 600, imgH = 400;
        const imgX = W - imgW - 120;
        const imgY = 200;
        
        svg += `<rect x="${imgX - 4}" y="${imgY - 4}" width="${imgW + 8}" height="${imgH + 8}" rx="8" fill="${colors.accent}" opacity="0.1"/>`;
        svg += `<image href="${imgSrc}" x="${imgX}" y="${imgY}" width="${imgW}" height="${imgH}" preserveAspectRatio="xMidYMid slice"/>`;
        
        // Caption
        if (body.caption) {
          svg += `<text x="${imgX + imgW/2}" y="${imgY + imgH + 40}" text-anchor="middle" font-size="18" fill="${colors.muted}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(body.caption)}</text>`;
        }
      }
      
      // Text
      let y = 220;
      const text = body.text;
      
      if (Array.isArray(text)) {
        text.forEach(item => {
          svg += `<circle cx="140" cy="${y - 10}" r="6" fill="${colors.bullet}"/>`;
          svg += `<text x="170" y="${y}" font-size="28" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(item)}</text>`;
          y += 60;
        });
      }
      
      return svg;
    }

    function renderSplitLayout(body, colors, W, H) {
      let svg = '';
      const direction = body.direction || 'horizontal';
      
      if (direction === 'horizontal') {
        const leftX = 120;
        const rightX = W/2 + 60;
        
        // Left
        if (body.left) {
          let y = 220;
          if (body.left.title) {
            svg += `<text x="${leftX}" y="${y}" font-size="32" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(body.left.title)}</text>`;
            y += 60;
          }
          (body.left.text || []).forEach(item => {
            svg += `<circle cx="${leftX + 20}" cy="${y - 10}" r="5" fill="${colors.bullet}"/>`;
            svg += `<text x="${leftX + 50}" y="${y}" font-size="24" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(item)}</text>`;
            y += 50;
          });
        }
        
        // Divider
        svg += `<line x1="${W/2}" y1="180" x2="${W/2}" y2="${H - 100}" stroke="${colors.muted}" stroke-width="2" opacity="0.3"/>`;
        
        // Right
        if (body.right) {
          let y = 220;
          if (body.right.title) {
            svg += `<text x="${rightX}" y="${y}" font-size="32" font-weight="600" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(body.right.title)}</text>`;
            y += 60;
          }
          (body.right.text || []).forEach(item => {
            svg += `<circle cx="${rightX + 20}" cy="${y - 10}" r="5" fill="${colors.bullet}"/>`;
            svg += `<text x="${rightX + 50}" y="${y}" font-size="24" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(item)}</text>`;
            y += 50;
          });
        }
      }
      
      return svg;
    }

    function renderDiagram(diagram, colors, W, H) {
      let svg = '';
      
      if (diagram.type === 'box-arrow') {
        const boxes = diagram.boxes || [];
        const boxW = 200, boxH = 80;
        const gap = 100;
        const totalW = boxes.length * boxW + (boxes.length - 1) * gap;
        let x = (W - totalW) / 2;
        const y = H/2 + 50;
        
        boxes.forEach((box, i) => {
          // Box
          svg += `<rect x="${x}" y="${y}" width="${boxW}" height="${boxH}" rx="8" fill="${colors.accent}" opacity="0.1" stroke="${colors.accent}" stroke-width="2"/>`;
          svg += `<text x="${x + boxW/2}" y="${y + boxH/2 + 8}" text-anchor="middle" font-size="20" font-weight="500" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(box)}</text>`;
          
          // Arrow
          if (i < boxes.length - 1) {
            const arrowX = x + boxW + 10;
            const arrowY = y + boxH/2;
            svg += `<line x1="${arrowX}" y1="${arrowY}" x2="${arrowX + gap - 20}" y2="${arrowY}" stroke="${colors.accent}" stroke-width="3"/>`;
            svg += `<polygon points="${arrowX + gap - 20},${arrowY - 8} ${arrowX + gap - 10},${arrowY} ${arrowX + gap - 20},${arrowY + 8}" fill="${colors.accent}"/>`;
          }
          
          x += boxW + gap;
        });
      }
      
      return svg;
    }

    // Render Mermaid-style flowchart
    function renderFlowchart(flowchartConfig, colors, W, H) {
      let svg = '';
      
      // Support both string and object format
      let flowchartStr, style;
      if (typeof flowchartConfig === 'string') {
        flowchartStr = flowchartConfig;
        style = {};
      } else {
        flowchartStr = flowchartConfig.content || flowchartConfig.chart || '';
        style = flowchartConfig.style || {};
      }
      
      // Style options
      const nodeWidth = style.nodeWidth || 140;
      const nodeHeight = style.nodeHeight || 60;
      const fontSize = style.fontSize || 18;
      const gapX = style.gapX || 80;
      const gapY = style.gapY || 80;
      const startX = style.x || 200;
      const startY = style.y || 220;
      
      // Parse flowchart string
      const lines = flowchartStr.trim().split('\n').map(l => l.trim()).filter(l => l);
      
      // Detect direction
      let direction = 'LR';  // default: left to right
      const dirMatch = lines[0].match(/^direction:\s*(LR|RL|TB|BT)$/i);
      if (dirMatch) {
        direction = dirMatch[1].toUpperCase();
        lines.shift();
      }
      
      // Parse nodes and connections
      const nodes = new Map();  // id -> {id, label, type}
      const edges = [];         // {from, to, label, style}
      
      // Node patterns
      const nodePatterns = [
        { regex: /\[\[([^\]]+)\]\]/, type: 'rounded' },    // [[text]] - stadium/rounded
        { regex: /\(\(([^)]+)\)\)/, type: 'circle' },      // ((text)) - circle
        { regex: /\{([^}]+)\}/, type: 'diamond' },         // {text} - diamond
        { regex: /\[([^\]]+)\]/, type: 'rect' },           // [text] - rectangle
        { regex: /\(([^)]+)\)/, type: 'roundRect' },       // (text) - round rectangle
        { regex: />([^>]+)\]/, type: 'flag' },             // >text] - flag
      ];
      
      // Edge patterns
      const edgePatterns = [
        { regex: /-->\|([^|]+)\|/, style: 'arrow', hasLabel: true },
        { regex: /-->/, style: 'arrow', hasLabel: false },
        { regex: /-\.->\|([^|]+)\|/, style: 'dashed', hasLabel: true },
        { regex: /-\.->/, style: 'dashed', hasLabel: false },
        { regex: /===>\|([^|]+)\|/, style: 'thick', hasLabel: true },
        { regex: /===>/, style: 'thick', hasLabel: false },
        { regex: /---\|([^|]+)\|/, style: 'line', hasLabel: true },
        { regex: /---/, style: 'line', hasLabel: false },
      ];
      
      // Parse each line
      lines.forEach(line => {
        // Try to parse as edge definition
        let matched = false;
        
        for (const ep of edgePatterns) {
          const parts = line.split(ep.regex);
          if (parts.length >= 2) {
            const fromPart = parts[0].trim();
            const label = ep.hasLabel ? parts[1] : '';
            const toPart = parts[parts.length - 1].trim();
            
            // Parse from node
            const fromNode = parseFlowchartNode(fromPart, nodePatterns);
            if (fromNode && !nodes.has(fromNode.id)) {
              nodes.set(fromNode.id, fromNode);
            }
            
            // Parse to node
            const toNode = parseFlowchartNode(toPart, nodePatterns);
            if (toNode && !nodes.has(toNode.id)) {
              nodes.set(toNode.id, toNode);
            }
            
            if (fromNode && toNode) {
              edges.push({
                from: fromNode.id,
                to: toNode.id,
                label: label,
                style: ep.style
              });
              matched = true;
            }
            break;
          }
        }
        
        // Single node definition
        if (!matched) {
          const node = parseFlowchartNode(line, nodePatterns);
          if (node && !nodes.has(node.id)) {
            nodes.set(node.id, node);
          }
        }
      });
      
      // Layout nodes
      const nodeArray = Array.from(nodes.values());
      const nodePositions = layoutFlowchartNodes(nodeArray, edges, direction, W, H, {
        nodeWidth, nodeHeight, gapX, gapY, startX, startY
      });
      
      // Arrow marker
      svg += `<defs>
        <marker id="fc-arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="${colors.accent}"/>
        </marker>
      </defs>`;
      
      // Draw edges first (behind nodes)
      edges.forEach(edge => {
        const fromPos = nodePositions.get(edge.from);
        const toPos = nodePositions.get(edge.to);
        if (!fromPos || !toPos) return;
        
        const strokeWidth = edge.style === 'thick' ? 4 : 2;
        const dashArray = edge.style === 'dashed' ? '8,4' : 'none';
        const markerEnd = edge.style === 'line' ? '' : 'marker-end="url(#fc-arrow)"';
        
        // Calculate edge points
        const [x1, y1, x2, y2] = getEdgePoints(fromPos, toPos, direction);
        
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${colors.accent}" stroke-width="${strokeWidth}" stroke-dasharray="${dashArray}" ${markerEnd}/>`;
        
        // Edge label
        if (edge.label) {
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2 - 10;
          svg += `<rect x="${midX - 30}" y="${midY - 14}" width="60" height="20" rx="4" fill="${colors.background}"/>`;
          svg += `<text x="${midX}" y="${midY}" text-anchor="middle" font-size="${fontSize * 0.8}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(edge.label)}</text>`;
        }
      });
      
      // Draw nodes
      nodeArray.forEach(node => {
        const pos = nodePositions.get(node.id);
        if (!pos) return;
        
        const { x, y, w, h } = pos;
        
        switch (node.type) {
          case 'rect':
            svg += `<rect x="${x - w/2}" y="${y - h/2}" width="${w}" height="${h}" rx="4" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
            break;
          case 'roundRect':
            svg += `<rect x="${x - w/2}" y="${y - h/2}" width="${w}" height="${h}" rx="20" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
            break;
          case 'rounded':
            svg += `<rect x="${x - w/2}" y="${y - h/2}" width="${w}" height="${h}" rx="${h/2}" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
            break;
          case 'circle':
            const r = Math.max(w, h) / 2;
            svg += `<circle cx="${x}" cy="${y}" r="${r}" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
            break;
          case 'diamond':
            const dw = w * 0.7, dh = h * 0.7;
            svg += `<polygon points="${x},${y-dh} ${x+dw},${y} ${x},${y+dh} ${x-dw},${y}" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
            break;
          default:
            svg += `<rect x="${x - w/2}" y="${y - h/2}" width="${w}" height="${h}" rx="4" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
        }
        
        // Node label
        svg += `<text x="${x}" y="${y + fontSize * 0.35}" text-anchor="middle" font-size="${fontSize}" fill="${colors.accent}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif" font-weight="500">${escapeHtml(node.label)}</text>`;
      });
      
      return svg;
    }
    
    function parseFlowchartNode(str, patterns) {
      str = str.trim();
      if (!str) return null;
      
      // Extract ID and find node definition
      let id = str;
      let label = str;
      let type = 'rect';
      
      for (const p of patterns) {
        const match = str.match(p.regex);
        if (match) {
          label = match[1];
          type = p.type;
          // ID is the part before the bracket/paren
          const bracketIndex = str.search(/[\[\(\{<]/);
          id = bracketIndex > 0 ? str.substring(0, bracketIndex).trim() : label;
          break;
        }
      }
      
      // If no pattern matched, check if it's just an ID
      if (id === str && !str.match(/[\[\(\{]/)) {
        return { id: str, label: str, type: 'rect' };
      }
      
      return { id: id || label, label, type };
    }
    
    function layoutFlowchartNodes(nodes, edges, direction, W, H, style) {
      const positions = new Map();
      
      const nodeW = style.nodeWidth;
      const nodeH = style.nodeHeight;
      const gapX = style.gapX;
      const gapY = style.gapY;
      const startX = style.startX;
      const startY = style.startY;
      
      // Build graph structure
      const outgoing = new Map();  // node -> [targets]
      const incoming = new Map();  // node -> [sources]
      
      nodes.forEach(n => {
        outgoing.set(n.id, []);
        incoming.set(n.id, []);
      });
      
      edges.forEach(e => {
        if (outgoing.has(e.from)) outgoing.get(e.from).push(e.to);
        if (incoming.has(e.to)) incoming.get(e.to).push(e.from);
      });
      
      // Find root nodes (no incoming edges)
      const roots = nodes.filter(n => incoming.get(n.id).length === 0);
      if (roots.length === 0 && nodes.length > 0) roots.push(nodes[0]);
      
      // BFS to assign levels
      const levels = new Map();
      const visited = new Set();
      let queue = roots.map(r => ({ node: r, level: 0 }));
      
      while (queue.length > 0) {
        const { node, level } = queue.shift();
        if (visited.has(node.id)) continue;
        visited.add(node.id);
        levels.set(node.id, level);
        
        outgoing.get(node.id).forEach(targetId => {
          const target = nodes.find(n => n.id === targetId);
          if (target && !visited.has(targetId)) {
            queue.push({ node: target, level: level + 1 });
          }
        });
      }
      
      // Handle unvisited nodes
      nodes.forEach(n => {
        if (!levels.has(n.id)) levels.set(n.id, 0);
      });
      
      // Group by level
      const levelGroups = new Map();
      nodes.forEach(n => {
        const lvl = levels.get(n.id);
        if (!levelGroups.has(lvl)) levelGroups.set(lvl, []);
        levelGroups.get(lvl).push(n);
      });
      
      // Calculate positions
      const maxLevel = Math.max(...levels.values());
      
      const isHorizontal = direction === 'LR' || direction === 'RL';
      const isReverse = direction === 'RL' || direction === 'BT';
      
      levelGroups.forEach((group, level) => {
        const actualLevel = isReverse ? maxLevel - level : level;
        
        group.forEach((node, idx) => {
          let x, y;
          
          if (isHorizontal) {
            x = startX + actualLevel * (nodeW + gapX) + nodeW / 2;
            const totalHeight = group.length * nodeH + (group.length - 1) * gapY;
            const startYGroup = (H - totalHeight) / 2 + 50;
            y = startYGroup + idx * (nodeH + gapY) + nodeH / 2;
          } else {
            const totalWidth = group.length * nodeW + (group.length - 1) * gapX;
            const startXGroup = (W - totalWidth) / 2;
            x = startXGroup + idx * (nodeW + gapX) + nodeW / 2;
            y = startY + actualLevel * (nodeH + gapY) + nodeH / 2;
          }
          
          positions.set(node.id, { x, y, w: nodeW, h: nodeH });
        });
      });
      
      return positions;
    }
    
    function getEdgePoints(fromPos, toPos, direction) {
      const { x: x1, y: y1, w: w1, h: h1 } = fromPos;
      const { x: x2, y: y2, w: w2, h: h2 } = toPos;
      
      const isHorizontal = direction === 'LR' || direction === 'RL';
      
      if (isHorizontal) {
        const startX = x1 < x2 ? x1 + w1/2 : x1 - w1/2;
        const endX = x1 < x2 ? x2 - w2/2 - 5 : x2 + w2/2 + 5;
        return [startX, y1, endX, y2];
      } else {
        const startY = y1 < y2 ? y1 + h1/2 : y1 - h1/2;
        const endY = y1 < y2 ? y2 - h2/2 - 5 : y2 + h2/2 + 5;
        return [x1, startY, x2, endY];
      }
    }

    // Render sequence diagram
    function renderSequence(sequenceConfig, colors, W, H) {
      let svg = '';
      
      // Support both string and object format
      let sequenceStr, style;
      if (typeof sequenceConfig === 'string') {
        sequenceStr = sequenceConfig;
        style = {};
      } else {
        sequenceStr = sequenceConfig.content || sequenceConfig.chart || '';
        style = sequenceConfig.style || {};
      }
      
      // Style options
      const participantWidth = style.participantWidth || 120;
      const participantHeight = style.participantHeight || 50;
      const messageGap = style.messageGap || 70;
      const fontSize = style.fontSize || 18;
      const startY = style.y || 220;
      const marginX = style.marginX || 150;
      
      const lines = sequenceStr.trim().split('\n').map(l => l.trim()).filter(l => l);
      
      // Parse participants and messages
      const participants = [];
      const messages = [];
      
      // Message patterns
      const msgPatterns = [
        { regex: /^(.+?)\s*->>>\s*(.+?):\s*(.*)$/, type: 'async-reply' },
        { regex: /^(.+?)\s*-->>>\s*(.+?):\s*(.*)$/, type: 'async-reply-dashed' },
        { regex: /^(.+?)\s*->>\s*(.+?):\s*(.*)$/, type: 'async' },
        { regex: /^(.+?)\s*-->>>\s*(.+?):\s*(.*)$/, type: 'reply-dashed' },
        { regex: /^(.+?)\s*-->>\s*(.+?):\s*(.*)$/, type: 'reply' },
        { regex: /^(.+?)\s*->\s*(.+?):\s*(.*)$/, type: 'sync' },
        { regex: /^(.+?)\s*-->\s*(.+?):\s*(.*)$/, type: 'dashed' },
        { regex: /^(.+?)\s*-x\s*(.+?):\s*(.*)$/, type: 'cross' },
      ];
      
      lines.forEach(line => {
        // Check for participant declaration
        const partMatch = line.match(/^participant\s+(.+)$/i);
        if (partMatch) {
          const name = partMatch[1].trim();
          if (!participants.includes(name)) participants.push(name);
          return;
        }
        
        // Check for message
        for (const mp of msgPatterns) {
          const match = line.match(mp.regex);
          if (match) {
            const from = match[1].trim();
            const to = match[2].trim();
            const text = match[3].trim();
            
            if (!participants.includes(from)) participants.push(from);
            if (!participants.includes(to)) participants.push(to);
            
            messages.push({ from, to, text, type: mp.type });
            break;
          }
        }
      });
      
      // Layout
      const totalW = participants.length * participantWidth + (participants.length - 1) * 80;
      const startX = Math.max(marginX, (W - totalW) / 2);
      const gap = (W - 2 * marginX) / Math.max(participants.length - 1, 1);
      
      // Participant positions
      const partPositions = new Map();
      participants.forEach((p, i) => {
        const x = participants.length === 1 ? W / 2 : startX + i * gap;
        partPositions.set(p, x);
      });
      
      // Arrow markers
      svg += `<defs>
        <marker id="seq-arrow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
          <polygon points="0 0, 8 3, 0 6" fill="${colors.accent}"/>
        </marker>
        <marker id="seq-arrow-open" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
          <polyline points="0 0, 8 3, 0 6" fill="none" stroke="${colors.accent}" stroke-width="1.5"/>
        </marker>
        <marker id="seq-cross" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
          <line x1="2" y1="2" x2="8" y2="8" stroke="${colors.accent}" stroke-width="2"/>
          <line x1="8" y1="2" x2="2" y2="8" stroke="${colors.accent}" stroke-width="2"/>
        </marker>
      </defs>`;
      
      // Draw lifelines
      const lifelineEndY = startY + participantHeight + messages.length * messageGap + 50;
      participants.forEach(p => {
        const x = partPositions.get(p);
        svg += `<line x1="${x}" y1="${startY + participantHeight}" x2="${x}" y2="${lifelineEndY}" stroke="${colors.muted}" stroke-width="2" stroke-dasharray="8,4"/>`;
      });
      
      // Draw participant boxes (top)
      participants.forEach(p => {
        const x = partPositions.get(p);
        svg += `<rect x="${x - participantWidth/2}" y="${startY}" width="${participantWidth}" height="${participantHeight}" rx="6" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
        svg += `<text x="${x}" y="${startY + participantHeight/2 + fontSize * 0.35}" text-anchor="middle" font-size="${fontSize}" fill="${colors.accent}" font-weight="500" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(p)}</text>`;
      });
      
      // Draw messages
      messages.forEach((msg, i) => {
        const fromX = partPositions.get(msg.from);
        const toX = partPositions.get(msg.to);
        const y = startY + participantHeight + 40 + i * messageGap;
        
        const isSelf = msg.from === msg.to;
        const isDashed = msg.type.includes('dashed') || msg.type === 'reply';
        const isOpen = msg.type.includes('async') || msg.type.includes('reply');
        const isCross = msg.type === 'cross';
        
        let marker = 'seq-arrow';
        if (isOpen) marker = 'seq-arrow-open';
        if (isCross) marker = 'seq-cross';
        
        if (isSelf) {
          // Self message (loop)
          const loopW = 50;
          svg += `<path d="M ${fromX} ${y} h ${loopW} v 30 h -${loopW}" fill="none" stroke="${colors.accent}" stroke-width="2" ${isDashed ? 'stroke-dasharray="6,3"' : ''} marker-end="url(#${marker})"/>`;
          svg += `<text x="${fromX + loopW + 10}" y="${y + 15}" font-size="${fontSize * 0.9}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(msg.text)}</text>`;
        } else {
          const direction = toX > fromX ? 1 : -1;
          svg += `<line x1="${fromX}" y1="${y}" x2="${toX - direction * 5}" y2="${y}" stroke="${colors.accent}" stroke-width="2" ${isDashed ? 'stroke-dasharray="6,3"' : ''} marker-end="url(#${marker})"/>`;
          
          // Message text
          const textX = (fromX + toX) / 2;
          svg += `<text x="${textX}" y="${y - 10}" text-anchor="middle" font-size="${fontSize * 0.9}" fill="${colors.text}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(msg.text)}</text>`;
        }
      });
      
      // Draw participant boxes (bottom)
      participants.forEach(p => {
        const x = partPositions.get(p);
        svg += `<rect x="${x - participantWidth/2}" y="${lifelineEndY}" width="${participantWidth}" height="${participantHeight}" rx="6" fill="${colors.accent}" opacity="0.15" stroke="${colors.accent}" stroke-width="2"/>`;
        svg += `<text x="${x}" y="${lifelineEndY + participantHeight/2 + fontSize * 0.35}" text-anchor="middle" font-size="${fontSize}" fill="${colors.accent}" font-weight="500" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(p)}</text>`;
      });
      
      return svg;
    }

    function renderHeader(meta, colors, W, pageNum, totalPages) {
      let svg = '';
      const header = meta.header || {};
      const format = header.format || {};
      const text = replacePlaceholders(header.text || '', meta, pageNum, totalPages);
      
      const bgColor = format.background || colors.headerBg;
      const textColor = format.color || colors.muted;
      const textSize = format.size || 28;
      
      svg += `<rect x="0" y="0" width="${W}" height="50" fill="${bgColor}"/>`;
      svg += `<text x="60" y="36" font-size="${textSize}" fill="${textColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(text)}</text>`;
      
      return svg;
    }

    function renderFooter(meta, colors, W, H, pageNum, totalPages) {
      let svg = '';
      const footer = meta.footer || {};
      const format = footer.format || {};
      const footerY = H - 32;
      
      const bgColor = format.background || colors.footerBg;
      const textColor = format.color || colors.muted;
      const textSize = format.size || 28;
      
      svg += `<rect x="0" y="${H - 50}" width="${W}" height="50" fill="${bgColor}"/>`;
      
      const left = replacePlaceholders(footer.left || '', meta, pageNum, totalPages);
      const center = replacePlaceholders(footer.center || '', meta, pageNum, totalPages);
      const right = replacePlaceholders(footer.right || '', meta, pageNum, totalPages);
      
      svg += `<text x="60" y="${footerY}" font-size="${textSize}" fill="${textColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(left)}</text>`;
      svg += `<text x="${W/2}" y="${footerY}" text-anchor="middle" font-size="${textSize}" fill="${textColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(center)}</text>`;
      svg += `<text x="${W - 60}" y="${footerY}" text-anchor="end" font-size="${textSize}" fill="${textColor}" font-family="${colors.headingFont}, ${colors.bodyFont}, sans-serif">${escapeHtml(right)}</text>`;
      
      return svg;
    }

    function replacePlaceholders(text, meta, pageNum, totalPages) {
      return text
        .replace(/{project}/g, meta.project || '')
        .replace(/{author}/g, meta.author || '')
        .replace(/{date}/g, meta.date || '')
        .replace(/{page}/g, pageNum)
        .replace(/{total}/g, totalPages);
    }

    function getImageSrc(figure) {
      if (figure.startsWith('http://') || figure.startsWith('https://')) {
        return figure;
      }
      return uploadedImages.get(figure) || `https://via.placeholder.com/600x400/e0e0e0/999?text=${encodeURIComponent(figure)}`;
    }

    function wrapText(text, maxChars) {
      const words = text.split(' ');
      const lines = [];
      let current = '';
      
      words.forEach(word => {
        if ((current + ' ' + word).trim().length <= maxChars) {
          current = (current + ' ' + word).trim();
        } else {
          if (current) lines.push(current);
          current = word;
        }
      });
      if (current) lines.push(current);
      
      return lines;
    }

    function escapeHtml(text) {
      if (!text) return '';
      return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    // Navigation
    function prevSlide() {
      if (currentSlide > 0) {
        currentSlide--;
        renderOutline();
        renderSlide();
      }
    }

    function nextSlide() {
      if (parsedData && parsedData.slides && currentSlide < parsedData.slides.length - 1) {
        currentSlide++;
        renderOutline();
        renderSlide();
      }
    }

    // Slideshow
    function startSlideshow() {
      if (!parsedData || !parsedData.slides || parsedData.slides.length === 0) return;
      
      slideshowSlide = currentSlide;
      const modal = document.getElementById('slideshow-modal');
      modal.classList.add('active');
      renderSlideshowSlide();
      document.addEventListener('keydown', slideshowKeyHandler);
      
      // Listen for fullscreen changes
      document.addEventListener('fullscreenchange', handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    }

    function endSlideshow() {
      const modal = document.getElementById('slideshow-modal');
      modal.classList.remove('active');
      modal.classList.remove('fullscreen');
      document.removeEventListener('keydown', slideshowKeyHandler);
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      
      // Exit fullscreen if active
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }

    function toggleFullscreen() {
      const modal = document.getElementById('slideshow-modal');
      
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      } else {
        // Enter fullscreen
        if (modal.requestFullscreen) {
          modal.requestFullscreen();
        } else if (modal.webkitRequestFullscreen) {
          modal.webkitRequestFullscreen();
        }
      }
    }

    function handleFullscreenChange() {
      const modal = document.getElementById('slideshow-modal');
      const btn = document.getElementById('fullscreen-btn');
      
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        modal.classList.add('fullscreen');
        btn.textContent = '‚õ∂ Exit Fullscreen';
      } else {
        modal.classList.remove('fullscreen');
        btn.textContent = '‚õ∂ Fullscreen';
      }
    }

    function handleSlideshowClick(event) {
      // Don't navigate if clicking on controls
      if (event.target.closest('.slideshow-controls')) return;
      
      // Click on left third = prev, right two-thirds = next
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const width = rect.width;
      
      if (x < width / 3) {
        prevSlideshowSlide();
      } else {
        nextSlideshowSlide();
      }
    }

    function slideshowKeyHandler(e) {
      if (e.key === 'Escape') {
        // If in fullscreen, just exit fullscreen (browser handles this)
        // If not in fullscreen, end slideshow
        if (!document.fullscreenElement && !document.webkitFullscreenElement) {
          endSlideshow();
        }
      }
      if (e.key === 'ArrowLeft') prevSlideshowSlide();
      if (e.key === 'ArrowRight' || e.key === ' ') nextSlideshowSlide();
      if (e.key === 'f' || e.key === 'F') toggleFullscreen();
    }

    function renderSlideshowSlide() {
      const container = document.getElementById('slideshow-slide');
      const pageInfo = document.getElementById('slideshow-page');
      const total = parsedData.slides.length;
      
      slideshowSlide = Math.max(0, Math.min(slideshowSlide, total - 1));
      pageInfo.textContent = `${slideshowSlide + 1} / ${total}`;
      
      const slide = parsedData.slides[slideshowSlide];
      const meta = parsedData.meta || {};
      const globalFormat = meta.format || {};
      const slideFormat = slide.format || {};
      const format = mergeFormat(globalFormat, slideFormat);
      
      container.innerHTML = generateSlideSVG(slide, meta, format, slideshowSlide + 1, total);
    }

    function prevSlideshowSlide() {
      if (slideshowSlide > 0) {
        slideshowSlide--;
        renderSlideshowSlide();
      }
    }

    function nextSlideshowSlide() {
      if (slideshowSlide < parsedData.slides.length - 1) {
        slideshowSlide++;
        renderSlideshowSlide();
      }
    }

    // File operations
    function openProject() {
      document.getElementById('file-input').click();
    }

    document.getElementById('file-input').addEventListener('change', async e => {
      const file = e.target.files[0];
      if (!file) return;

      if (file.name.endsWith('.fnote')) {
        const zip = await JSZip.loadAsync(file);
        
        // Load YAML
        const yamlFile = zip.file('presentation.pdl.yaml');
        if (yamlFile) {
          const content = await yamlFile.async('string');
          if (monacoEditor) monacoEditor.setValue(content);
        }
        
        // Load images
        uploadedImages.clear();
        const imageFiles = zip.folder('images');
        if (imageFiles) {
          for (const [path, zipEntry] of Object.entries(zip.files)) {
            if (path.startsWith('images/') && !zipEntry.dir) {
              const name = path.replace('images/', '');
              const data = await zipEntry.async('base64');
              const ext = name.split('.').pop().toLowerCase();
              const mime = ext === 'png' ? 'image/png' : ext === 'gif' ? 'image/gif' : 'image/jpeg';
              uploadedImages.set(name, `data:${mime};base64,${data}`);
            }
          }
        }
        renderImageGrid();
        showNotification('Project loaded', 'success');
      } else {
        // Plain YAML
        const reader = new FileReader();
        reader.onload = e => {
          if (monacoEditor) monacoEditor.setValue(e.target.result);
          showNotification('File loaded', 'success');
        };
        reader.readAsText(file);
      }
      
      e.target.value = '';
    });

    async function saveProject() {
      const content = monacoEditor ? monacoEditor.getValue() : '';
      const zip = new JSZip();
      
      // Add manifest
      zip.file('manifest.json', JSON.stringify({
        version: '0.3',
        app: 'FrameNote',
        created: new Date().toISOString()
      }, null, 2));
      
      // Add YAML
      zip.file('presentation.pdl.yaml', content);
      
      // Add images
      const imagesFolder = zip.folder('images');
      uploadedImages.forEach((data, name) => {
        const base64 = data.split(',')[1];
        imagesFolder.file(name, base64, { base64: true });
      });
      
      // Generate and download
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      let filename = 'presentation';
      try {
        const data = jsyaml.load(content);
        if (data?.meta?.project) {
          filename = data.meta.project.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
        }
      } catch (e) {}
      
      a.download = `${filename}.fnote`;
      a.click();
      URL.revokeObjectURL(url);
      
      showNotification('Project saved', 'success');
    }

    // Sample
    function loadSample() {
      const sample = `# FrameNote v0.4.1 Sample - Templates & Themes Demo
meta:
  project: FrameNote Templates
  author: FrameNote Team
  version: "0.4.1"
  date: "2025-01-01"
  # Theme can be set here (or use UI selector)
  # Options: default, corporate, minimal, dark, nature, sunset, ocean, lavender, rose, midnight
  theme: default
  # Font can be set here (or use UI selector)
  # Presets: sans, serif, rounded, business, modern, elegant, handwritten
  # Or detailed: font: { heading: "Montserrat", body: "Noto Sans JP", code: "Fira Code" }
  font: sans
  header:
    show: true
    text: "{project}"
    format:
      color: "#666666"
      size: 28
      background: "#f8f8f8"
  footer:
    show: true
    left: "{author}"
    center: ""
    right: "{page} / {total}"
    format:
      color: "#999999"
      size: 28
      background: "#f8f8f8"

slides:
  # Title Template
  - template: title
    title: "FrameNote v0.4.1"
    subtitle: "Templates & Themes"
    author: "FrameNote Team"
    date: "2025"

  # Agenda Template
  - template: agenda
    title: "‰ªäÊó•„ÅÆÂÜÖÂÆπ"
    items:
      - "„ÉÜ„É≥„Éó„É¨„Éº„ÉàÁ¥π‰ªã"
      - "„ÉÜ„Éº„Éû„Ç∑„Çπ„ÉÜ„É†"
      - "„ÉÄ„Ç§„Ç¢„Ç∞„É©„É†"
      - "„Åæ„Å®„ÇÅ"

  # Section Template
  - template: section
    title: "Part 1"
    subtitle: "„ÉÜ„É≥„Éó„É¨„Éº„ÉàÁ¥π‰ªã"

  # Quote Template
  - template: quote
    quote: "„Ç∑„É≥„Éó„É´„Åï„ÅØÁ©∂Ê•µ„ÅÆÊ¥óÁ∑¥„Åß„ÅÇ„Çã"
    author: "„É¨„Ç™„Éä„É´„Éâ„Éª„ÉÄ„Éª„É¥„Ç£„É≥„ÉÅ"

  # Standard Slide
  - title: „ÉÜ„Éº„Éû„Ç∑„Çπ„ÉÜ„É†
    body:
      text:
        - UI„Çª„É¨„ÇØ„Çø„Éº„Åæ„Åü„ÅØmeta.theme„ÅßÊåáÂÆö
        - "10Á®ÆÈ°û„ÅÆ„Éó„É™„Çª„ÉÉ„Éà: default, corporate, minimal, dark..."
        - meta.format„ÅßÂÄãÂà•„Ç´„Çπ„Çø„Éû„Ç§„Ç∫„ÇÇÂèØËÉΩ

  # Comparison Template
  - template: comparison
    title: "Before / After"
    left:
      label: "ÂæìÊù•„ÅÆÊñπÊ≥ï"
      items:
        - "GUI„ÅßÈÖçÁΩÆ"
        - "ÊâãÂãï„ÅßË™øÊï¥"
        - "ÂÜçÁèæÊÄß„Åå‰Ωé„ÅÑ"
    right:
      label: "FrameNote"
      items:
        - "„ÉÜ„Ç≠„Çπ„Éà„ÅßË®òËø∞"
        - "Ëá™Âãï„É¨„Ç§„Ç¢„Ç¶„Éà"
        - "ÂÆåÂÖ®„Å™ÂÜçÁèæÊÄß"

  # Timeline Template
  - template: timeline
    title: "„É≠„Éº„Éâ„Éû„ÉÉ„Éó"
    events:
      - date: "v0.1"
        title: "ÂàùÊúü„É™„É™„Éº„Çπ"
      - date: "v0.2"
        title: "PDLÂØæÂøú"
      - date: "v0.3"
        title: "„ÉÜ„É≥„Éó„É¨„Éº„Éà"
      - date: "v0.4.1"
        title: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà"

  # Diagram
  - title: „Éó„É≠„Çª„Çπ„Éï„É≠„Éº
    body:
      diagram:
        type: box-arrow
        direction: horizontal
        boxes:
          - ‰ºÅÁîª
          - Ë®≠Ë®à
          - ÈñãÁô∫
          - „É™„É™„Éº„Çπ

  # Table (Markdown format)
  - title: Ê©üËÉΩ‰∏ÄË¶ß
    body:
      table: |
        | Ê©üËÉΩ | Ë™¨Êòé | Áä∂ÊÖã |
        |:-----|:----:|-----:|
        | „ÉÜ„É≥„Éó„É¨„Éº„Éà | 8Á®ÆÈ°û„ÅÆ„Çπ„É©„Ç§„Éâ„ÉÜ„É≥„Éó„É¨„Éº„Éà | ‚úÖ |
        | „ÉÜ„Éº„Éû | 10Á®ÆÈ°û„ÅÆ„Ç´„É©„Éº„ÉÜ„Éº„Éû | ‚úÖ |
        | „Ç®„ÇØ„Çπ„Éù„Éº„Éà | PDF / PPTX / HTML | ‚úÖ |
        | „ÉÜ„Éº„Éñ„É´ | MarkdownÂΩ¢Âºè„ÅÆ„ÉÜ„Éº„Éñ„É´ | ‚úÖ |
      tableStyle:
        colWidths: [200, 450, 100]
        rowHeight: 52

  # Code Block
  - title: „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ
    body:
      code:
        language: python
        content: |
          def fibonacci(n):
              """Calculate fibonacci number"""
              if n <= 1:
                  return n
              return fibonacci(n-1) + fibonacci(n-2)
          
          # Print first 10 numbers
          for i in range(10):
              print(fibonacci(i))
        style:
          theme: match  # dark, light, or match („ÉÜ„Éº„Éû„Å´Âêà„Çè„Åõ„ÅüÈÖçËâ≤)

  # Math Equation
  - title: Êï∞Âºè
    body:
      text:
        - "„Ç¢„Ç§„É≥„Ç∑„É•„Çø„Ç§„É≥„ÅÆÂºè $E = mc^2$ „ÅØÊúâÂêç„Åß„Åô"
        - "„Éî„Çø„Ç¥„É©„Çπ„ÅÆÂÆöÁêÜ: $a^2 + b^2 = c^2$"
        - "Âäõ„ÅÆÊ≥ïÂâá: $F = ma$"

  # Shapes
  - title: Âõ≥ÂΩ¢ÊèèÁîª
    body:
      shapes:
        - type: rect
          x: 200
          y: 250
          width: 180
          height: 120
          fill: "#3b82f6"
          rx: 8
          label: "ÂÖ•Âäõ"
        - type: arrow
          x: 400
          y: 310
          x2: 550
          y2: 310
          strokeWidth: 3
        - type: circle
          x: 680
          y: 310
          r: 70
          fill: "#10b981"
          label: "Âá¶ÁêÜ"
        - type: arrow
          x: 770
          y: 310
          x2: 920
          y2: 310
          strokeWidth: 3
        - type: diamond
          x: 1050
          y: 310
          size: 140
          fill: "#f59e0b"
          label: "Âá∫Âäõ"

  # Flowchart (Mermaid-style)
  - title: „Éï„É≠„Éº„ÉÅ„É£„Éº„Éà
    body:
      flowchart: |
        direction: LR
        A[ÈñãÂßã] --> B(ÂÖ•ÂäõÂá¶ÁêÜ)
        B --> C{Ê§úË®º}
        C -->|OK| D[‰øùÂ≠ò]
        C -->|NG| B
        D --> E[ÁµÇ‰∫Ü]

  # Sequence Diagram
  - title: „Ç∑„Éº„Ç±„É≥„ÇπÂõ≥
    body:
      sequence: |
        Client ->> Server: HTTP„É™„ÇØ„Ç®„Çπ„Éà
        Server ->> DB: „ÇØ„Ç®„É™ÂÆüË°å
        DB -->> Server: ÁµêÊûúËøîÂç¥
        Server -->> Client: JSON„É¨„Çπ„Éù„É≥„Çπ

  # Q&A Template
  - template: qa
    title: "„ÅîË≥™Âïè„ÅØ„ÅÇ„Çä„Åæ„Åô„ÅãÔºü"
    contact: "github.com/fukuyori/framenote"

  # Thanks Template
  - template: thanks
    title: "„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åó„Åü"
    message: "„ÉÜ„Éº„Éû„ÇíÂ§âÊõ¥„Åó„Å¶Ë©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑÔºÅ"
    contact: "https://github.com/fukuyori/framenote"
`;
      if (monacoEditor) {
        monacoEditor.setValue(sample);
      }
    }

    // Notification
    function showNotification(message, type = 'success') {
      const existing = document.querySelector('.notification');
      if (existing) existing.remove();
      
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => notification.remove(), 3000);
    }

    // PDF Export
    async function exportPDF() {
      if (!parsedData || !parsedData.slides || parsedData.slides.length === 0) {
        showNotification('No slides to export', 'error');
        return;
      }

      showNotification('Generating PDF...', 'success');

      try {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: 'landscape',
          unit: 'px',
          format: [1920, 1080]
        });

        const meta = parsedData.meta || {};
        const globalFormat = meta.format || {};
        const total = parsedData.slides.length;

        for (let i = 0; i < total; i++) {
          if (i > 0) {
            pdf.addPage([1920, 1080], 'landscape');
          }

          const slide = parsedData.slides[i];
          const slideFormat = slide.format || {};
          const format = mergeFormat(globalFormat, slideFormat);
          
          const svgString = generateSlideSVG(slide, meta, format, i + 1, total);
          
          // Convert SVG to image
          const img = await svgToImage(svgString);
          pdf.addImage(img, 'PNG', 0, 0, 1920, 1080);
        }

        // Set PDF metadata
        pdf.setProperties({
          title: meta.project || 'Presentation',
          author: meta.author || 'FrameNote',
          creator: 'FrameNote v0.4.1'
        });

        // Download
        let filename = 'presentation';
        if (meta.project) {
          filename = meta.project.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
        }
        pdf.save(`${filename}.pdf`);
        
        showNotification('PDF exported successfully!', 'success');
      } catch (error) {
        console.error('PDF export error:', error);
        showNotification('PDF export failed: ' + error.message, 'error');
      }
    }

    function svgToImage(svgString) {
      return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = 1920;
        canvas.height = 1080;
        const ctx = canvas.getContext('2d');
        
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0);
          resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = reject;
        
        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        img.src = URL.createObjectURL(blob);
      });
    }

    // PPTX Export
    async function exportPPTX() {
      if (!parsedData || !parsedData.slides || parsedData.slides.length === 0) {
        showNotification('No slides to export', 'error');
        return;
      }

      showNotification('Generating PPTX...', 'success');

      try {
        const pptx = new PptxGenJS();
        const meta = parsedData.meta || {};
        const theme = getThemeColors(meta);
        
        // Set presentation properties
        pptx.author = meta.author || 'FrameNote';
        pptx.title = meta.project || 'Presentation';
        pptx.subject = 'Created with FrameNote v0.4.1';
        
        // Use standard 16:9 layout (13.33" x 7.5")
        pptx.layout = 'LAYOUT_16x9';
        
        // Slide dimensions for calculations
        const SW = 10;  // slide width in inches for positioning
        const SH = 5.63; // slide height in inches for positioning

        const globalFormat = meta.format || {};
        const total = parsedData.slides.length;

        for (let i = 0; i < total; i++) {
          const slideData = parsedData.slides[i];
          const slideFormat = slideData.format || {};
          const format = mergeFormat(globalFormat, slideFormat);
          const colors = {
            background: slideFormat.background?.color || format.background?.color || theme.background,
            accent: slideFormat.accent?.color || format.accent?.color || theme.accent,
            title: slideFormat.title?.color || format.title?.color || theme.title,
            text: slideFormat.text?.color || format.text?.color || theme.text,
            bullet: slideFormat.bullet?.color || format.bullet?.color || theme.bullet,
          };
          
          const slide = pptx.addSlide();
          slide.background = { color: colors.background.replace('#', '') };

          // Render based on template or standard
          if (slideData.template) {
            renderPPTXTemplate(pptx, slide, slideData, colors, meta, i + 1, total);
          } else {
            renderPPTXStandard(pptx, slide, slideData, colors, meta, i + 1, total);
          }

          // Header
          if (meta.header?.show) {
            const headerText = replacePlaceholders(meta.header.text || '', meta, i + 1, total);
            slide.addText(headerText, {
              x: 0.3, y: 0.1, w: '90%', h: 0.3,
              fontSize: 10, color: '666666'
            });
          }

          // Footer
          if (meta.footer?.show) {
            const left = replacePlaceholders(meta.footer.left || '', meta, i + 1, total);
            const right = replacePlaceholders(meta.footer.right || '', meta, i + 1, total);
            
            if (left) {
              slide.addText(left, {
                x: 0.3, y: 5.2, w: 3, h: 0.3,
                fontSize: 9, color: '999999'
              });
            }
            if (right) {
              slide.addText(right, {
                x: 10, y: 5.2, w: 3, h: 0.3,
                fontSize: 9, color: '999999', align: 'right'
              });
            }
          }
        }

        // Download
        let filename = 'presentation';
        if (meta.project) {
          filename = meta.project.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
        }
        await pptx.writeFile({ fileName: `${filename}.pptx` });
        
        showNotification('PPTX exported successfully!', 'success');
      } catch (error) {
        console.error('PPTX export error:', error);
        showNotification('PPTX export failed: ' + error.message, 'error');
      }
    }

    function renderPPTXTemplate(pptx, slide, data, colors, meta, pageNum, total) {
      const accentHex = colors.accent.replace('#', '');
      const titleHex = colors.title.replace('#', '');
      const textHex = colors.text.replace('#', '');

      switch (data.template) {
        case 'title':
          slide.addText(data.title || '', {
            x: 0.5, y: 2, w: '90%', h: 1,
            fontSize: 44, bold: true, color: titleHex, align: 'center'
          });
          if (data.subtitle) {
            slide.addText(data.subtitle, {
              x: 0.5, y: 3, w: '90%', h: 0.5,
              fontSize: 24, color: '666666', align: 'center'
            });
          }
          if (data.author) {
            slide.addText(data.author, {
              x: 0.5, y: 4.2, w: '90%', h: 0.4,
              fontSize: 16, color: '999999', align: 'center'
            });
          }
          if (data.date) {
            slide.addText(data.date, {
              x: 0.5, y: 4.6, w: '90%', h: 0.3,
              fontSize: 14, color: 'bbbbbb', align: 'center'
            });
          }
          // Accent bar
          slide.addShape('rect', {
            x: 0, y: 2.2, w: 0.05, h: 1.5, fill: { color: accentHex }
          });
          break;

        case 'section':
          slide.addShape('rect', {
            x: 3, y: 2.45, w: 7, h: 0.03, fill: { color: accentHex }
          });
          slide.addText(data.title || '', {
            x: 0.5, y: 1.8, w: '90%', h: 0.8,
            fontSize: 40, bold: true, color: accentHex, align: 'center'
          });
          if (data.subtitle) {
            slide.addText(data.subtitle, {
              x: 0.5, y: 2.7, w: '90%', h: 0.5,
              fontSize: 20, color: '666666', align: 'center'
            });
          }
          break;

        case 'quote':
          slide.addText('"', {
            x: 0.3, y: 1, w: 1, h: 1,
            fontSize: 120, color: accentHex, transparency: 80
          });
          slide.addText(data.quote || '', {
            x: 1, y: 1.8, w: 11, h: 1.5,
            fontSize: 28, italic: true, color: textHex, align: 'center'
          });
          if (data.author) {
            slide.addText('‚Äî ' + data.author, {
              x: 0.5, y: 3.8, w: '90%', h: 0.4,
              fontSize: 18, bold: true, color: accentHex, align: 'center'
            });
          }
          if (data.source) {
            slide.addText(data.source, {
              x: 0.5, y: 4.2, w: '90%', h: 0.3,
              fontSize: 14, color: '999999', align: 'center'
            });
          }
          break;

        case 'qa':
          slide.addText('?', {
            x: 5, y: 0.5, w: 3, h: 3,
            fontSize: 200, color: accentHex, transparency: 85, align: 'center'
          });
          slide.addText(data.title || 'Questions?', {
            x: 0.5, y: 2.2, w: '90%', h: 0.8,
            fontSize: 44, bold: true, color: titleHex, align: 'center'
          });
          if (data.contact) {
            slide.addText(data.contact, {
              x: 0.5, y: 3.2, w: '90%', h: 0.4,
              fontSize: 18, color: accentHex, align: 'center'
            });
          }
          break;

        case 'thanks':
          slide.addText(data.title || 'Thank You!', {
            x: 0.5, y: 2, w: '90%', h: 0.9,
            fontSize: 48, bold: true, color: titleHex, align: 'center'
          });
          if (data.message) {
            slide.addText(data.message, {
              x: 0.5, y: 3, w: '90%', h: 0.4,
              fontSize: 18, color: '666666', align: 'center'
            });
          }
          if (data.contact) {
            slide.addText(data.contact, {
              x: 0.5, y: 3.5, w: '90%', h: 0.4,
              fontSize: 16, color: accentHex, align: 'center'
            });
          }
          break;

        case 'agenda':
          slide.addText(data.title || 'Agenda', {
            x: 0.5, y: 0.5, w: 5, h: 0.6,
            fontSize: 36, bold: true, color: titleHex
          });
          slide.addShape('rect', {
            x: 0.5, y: 1.05, w: 1.5, h: 0.03, fill: { color: accentHex }
          });
          const items = data.items || [];
          items.forEach((item, idx) => {
            const y = 1.5 + idx * 0.7;
            slide.addShape('ellipse', {
              x: 0.6, y: y, w: 0.35, h: 0.35, fill: { color: accentHex }
            });
            slide.addText(String(idx + 1), {
              x: 0.6, y: y, w: 0.35, h: 0.35,
              fontSize: 14, bold: true, color: 'FFFFFF', align: 'center', valign: 'middle'
            });
            slide.addText(item, {
              x: 1.1, y: y, w: 10, h: 0.4,
              fontSize: 20, color: textHex
            });
          });
          break;

        case 'comparison':
          if (data.title) {
            slide.addText(data.title, {
              x: 0.5, y: 0.3, w: '90%', h: 0.6,
              fontSize: 32, bold: true, color: titleHex, align: 'center'
            });
          }
          // Left side
          if (data.left) {
            slide.addShape('roundRect', {
              x: 0.3, y: 1.1, w: 6, h: 3.8, fill: { color: accentHex, transparency: 95 }
            });
            slide.addText(data.left.label || 'Left', {
              x: 0.5, y: 1.2, w: 5.6, h: 0.5,
              fontSize: 24, bold: true, color: accentHex, align: 'center'
            });
            (data.left.items || []).forEach((item, idx) => {
              slide.addText('‚Ä¢ ' + item, {
                x: 0.8, y: 1.8 + idx * 0.5, w: 5, h: 0.4,
                fontSize: 16, color: textHex
              });
            });
          }
          // Right side
          if (data.right) {
            slide.addShape('roundRect', {
              x: 6.7, y: 1.1, w: 6, h: 3.8, fill: { color: accentHex, transparency: 90 }
            });
            slide.addText(data.right.label || 'Right', {
              x: 6.9, y: 1.2, w: 5.6, h: 0.5,
              fontSize: 24, bold: true, color: accentHex, align: 'center'
            });
            (data.right.items || []).forEach((item, idx) => {
              slide.addText('‚Ä¢ ' + item, {
                x: 7.2, y: 1.8 + idx * 0.5, w: 5, h: 0.4,
                fontSize: 16, color: textHex
              });
            });
          }
          break;

        case 'timeline':
          if (data.title) {
            slide.addText(data.title, {
              x: 0.5, y: 0.3, w: '90%', h: 0.6,
              fontSize: 32, bold: true, color: titleHex, align: 'center'
            });
          }
          const events = data.events || [];
          if (events.length > 0) {
            const lineY = 2.8;
            const startX = 1;
            const endX = 12;
            const spacing = (endX - startX) / Math.max(events.length - 1, 1);
            
            // Timeline line
            slide.addShape('rect', {
              x: startX, y: lineY, w: endX - startX, h: 0.03, fill: { color: 'CCCCCC' }
            });
            
            events.forEach((event, idx) => {
              const x = events.length === 1 ? 6.5 : startX + idx * spacing;
              // Circle
              slide.addShape('ellipse', {
                x: x - 0.15, y: lineY - 0.12, w: 0.25, h: 0.25, fill: { color: accentHex }
              });
              // Date
              slide.addText(event.date || '', {
                x: x - 1, y: lineY - 0.7, w: 2, h: 0.4,
                fontSize: 16, bold: true, color: accentHex, align: 'center'
              });
              // Title
              slide.addText(event.title || '', {
                x: x - 1, y: lineY + 0.3, w: 2, h: 0.6,
                fontSize: 14, color: textHex, align: 'center'
              });
            });
          }
          break;

        default:
          renderPPTXStandard(pptx, slide, data, colors, meta, pageNum, total);
      }
    }

    function renderPPTXStandard(pptx, slide, data, colors, meta, pageNum, total) {
      const titleHex = colors.title.replace('#', '');
      const textHex = colors.text.replace('#', '');
      const bulletHex = colors.bullet.replace('#', '');
      const accentHex = colors.accent.replace('#', '');
      const bgHex = colors.background.replace('#', '');

      // Title
      if (data.title) {
        slide.addText(data.title, {
          x: 0.5, y: 0.4, w: '90%', h: 0.7,
          fontSize: 32, bold: true, color: titleHex
        });
      }

      // Body
      if (data.body) {
        const body = data.body;
        const text = body.text;
        
        if (body.table) {
          // Table (Markdown format)
          const { headers, rows, aligns } = parseMarkdownTable(body.table);
          if (headers.length > 0) {
            const tableStyle = body.tableStyle || {};
            const headerBgHex = (tableStyle.headerBg || colors.accent).replace('#', '');
            const headerColorHex = (tableStyle.headerColor || colors.background).replace('#', '');
            
            const tableData = [
              headers.map((h, colIdx) => ({ 
                text: h, 
                options: { 
                  bold: true, 
                  color: headerColorHex, 
                  fill: { color: headerBgHex },
                  align: 'center'  // headers always centered
                } 
              })),
              ...rows.map((row, i) => row.map((cell, colIdx) => ({ 
                text: cell.replace(/\*\*/g, ''), 
                options: { 
                  color: textHex,
                  fill: tableStyle.striped !== false && i % 2 === 1 ? { color: accentHex, transparency: 95 } : undefined,
                  align: aligns[colIdx] || 'left'
                } 
              })))
            ];
            
            // Calculate column widths for PPTX (convert pixels to inches, roughly /96)
            let pptxColWidths;
            if (tableStyle.colWidths && Array.isArray(tableStyle.colWidths)) {
              pptxColWidths = tableStyle.colWidths.map(w => w / 96);
            }
            
            const tableOptions = {
              x: 0.5, y: 1.3,
              fontSize: tableStyle.fontSize ? tableStyle.fontSize * 0.5 : 14,
              border: { pt: 0.5, color: '999999' },
              valign: 'middle'
            };
            
            if (pptxColWidths) {
              tableOptions.colW = pptxColWidths;
            } else {
              tableOptions.w = 9;
            }
            
            if (tableStyle.rowHeight) {
              tableOptions.rowH = tableStyle.rowHeight / 96;
            }
            
            slide.addTable(tableData, tableOptions);
          }
        } else if (body.diagram) {
          // Diagram
          const boxes = body.diagram.boxes || [];
          const boxW = 1.5;
          const gap = 0.8;
          const totalW = boxes.length * boxW + (boxes.length - 1) * gap;
          let x = (13 - totalW) / 2;
          const y = 2.5;
          
          boxes.forEach((box, i) => {
            slide.addShape('roundRect', {
              x: x, y: y, w: boxW, h: 0.7,
              fill: { color: bulletHex, transparency: 90 },
              line: { color: bulletHex, width: 1.5 }
            });
            slide.addText(box, {
              x: x, y: y, w: boxW, h: 0.7,
              fontSize: 14, bold: true, color: bulletHex, align: 'center', valign: 'middle'
            });
            
            if (i < boxes.length - 1) {
              slide.addShape('rightArrow', {
                x: x + boxW + 0.1, y: y + 0.2, w: gap - 0.2, h: 0.3,
                fill: { color: bulletHex }
              });
            }
            
            x += boxW + gap;
          });
        } else if (body.code) {
          // Code block
          const codeConfig = body.code;
          const content = typeof codeConfig === 'string' ? codeConfig : codeConfig.content || '';
          const language = codeConfig.language || '';
          const codeStyle = codeConfig.style || {};
          const lines = content.split('\n');
          
          // Helper functions for color manipulation
          function adjustColorHex(hex, amount) {
            hex = hex.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
          }
          
          function blendColorsHex(hex1, hex2, ratio) {
            hex1 = hex1.replace('#', '');
            hex2 = hex2.replace('#', '');
            const r = Math.round(parseInt(hex1.substr(0, 2), 16) * (1 - ratio) + parseInt(hex2.substr(0, 2), 16) * ratio);
            const g = Math.round(parseInt(hex1.substr(2, 2), 16) * (1 - ratio) + parseInt(hex2.substr(2, 2), 16) * ratio);
            const b = Math.round(parseInt(hex1.substr(4, 2), 16) * (1 - ratio) + parseInt(hex2.substr(4, 2), 16) * ratio);
            return [r, g, b].map(c => Math.max(0, Math.min(255, c)).toString(16).padStart(2, '0')).join('');
          }
          
          function getBrightnessHex(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return (r * 299 + g * 587 + b * 114) / 1000;
          }
          
          // Determine background color
          let codeBgHex, codeTextHex;
          const themeBgHex = bgHex;
          const isLightTheme = getBrightnessHex(themeBgHex) > 128;
          
          if (codeStyle.theme === 'match') {
            // Match theme colors
            if (isLightTheme) {
              codeBgHex = blendColorsHex(themeBgHex, accentHex, 0.08);
              codeBgHex = adjustColorHex(codeBgHex, -30);
              codeTextHex = adjustColorHex(themeBgHex, -180);
            } else {
              codeBgHex = blendColorsHex(themeBgHex, accentHex, 0.15);
              codeBgHex = adjustColorHex(codeBgHex, -20);
              codeTextHex = adjustColorHex(themeBgHex, 180);
            }
          } else if (codeStyle.background) {
            codeBgHex = codeStyle.background.replace('#', '');
            const brightness = getBrightnessHex(codeBgHex);
            codeTextHex = brightness > 128 ? '1e293b' : 'e0e0e0';
          } else if (codeStyle.theme === 'light') {
            codeBgHex = 'f8fafc';
            codeTextHex = '1e293b';
          } else {
            codeBgHex = '1e293b';
            codeTextHex = 'e0e0e0';
          }
          
          // Background for code
          slide.addShape('roundRect', {
            x: 0.5, y: 1.2, w: 9, h: Math.min(lines.length * 0.3 + 0.4, 4),
            fill: { color: codeBgHex },
            line: { color: '334155', width: 1 }
          });
          
          // Language badge
          if (language) {
            slide.addText(language, {
              x: 8.5, y: 1.2, w: 1, h: 0.3,
              fontSize: 10, color: 'ffffff', fill: { color: accentHex },
              align: 'center', valign: 'middle'
            });
          }
          
          // Code text (monospace)
          const codeText = lines.map((line, i) => ({
            text: (i + 1).toString().padStart(3) + '  ' + line + '\n',
            options: { fontFace: 'Consolas', fontSize: 11, color: codeTextHex }
          }));
          
          slide.addText(codeText, {
            x: 0.6, y: 1.4, w: 8.8, h: Math.min(lines.length * 0.3, 3.6),
            valign: 'top'
          });
        } else if (body.math) {
          // Math equation - display as text (LaTeX source)
          const mathConfig = body.math;
          const formula = typeof mathConfig === 'string' ? mathConfig : mathConfig.formula || mathConfig;
          const mathStyle = body.mathStyle || {};
          const fontSize = mathStyle.fontSize ? mathStyle.fontSize * 0.5 : 24;
          const align = mathStyle.align || 'center';
          
          // Display formula text
          slide.addText(formula, {
            x: 0.5, y: 2, w: 9, h: 1,
            fontSize: fontSize,
            color: textHex,
            fontFace: 'Cambria Math',
            align: align,
            valign: 'middle'
          });
          
          // Add note about math rendering
          slide.addText('(LaTeX: ' + formula.substring(0, 50) + (formula.length > 50 ? '...' : '') + ')', {
            x: 0.5, y: 3.2, w: 9, h: 0.4,
            fontSize: 10,
            color: '888888',
            align: 'center'
          });
        } else if (typeof text === 'string') {
          slide.addText(text, {
            x: 0.5, y: 1.3, w: '90%', h: 3,
            fontSize: 18, color: textHex
          });
        } else if (Array.isArray(text)) {
          text.forEach((item, idx) => {
            slide.addText('‚óè  ' + item, {
              x: 0.5, y: 1.3 + idx * 0.55, w: '90%', h: 0.5,
              fontSize: 18, color: textHex, bullet: false
            });
          });
        }
      }
    }

    // HTML Export
    function exportHTML() {
      if (!parsedData || !parsedData.slides || parsedData.slides.length === 0) {
        showNotification('No slides to export', 'error');
        return;
      }

      const meta = parsedData.meta || {};
      const globalFormat = meta.format || {};
      const total = parsedData.slides.length;
      const theme = getThemeColors(meta);
      const fonts = getFontSettings(meta);

      // Generate Google Fonts URL
      const fontFamilies = [...new Set([fonts.heading, fonts.body, fonts.code])];
      const googleFontsUrl = 'https://fonts.googleapis.com/css2?' + 
        fontFamilies.map(f => 'family=' + f.replace(/ /g, '+') + ':wght@400;700').join('&') + 
        '&display=swap';

      // Generate SVGs for all slides
      const slideSVGs = parsedData.slides.map((slide, i) => {
        const slideFormat = slide.format || {};
        const format = mergeFormat(globalFormat, slideFormat);
        return generateSlideSVG(slide, meta, format, i + 1, total);
      });

      // Build slide divs
      const slideDivs = slideSVGs.map((svg, i) => 
        '<div class="slide' + (i === 0 ? '' : ' hidden') + '" data-index="' + i + '">' + svg + '</div>'
      ).join('\n    ');

      // Build script content separately to avoid parser issues
      const scriptContent = `
    let current = 0;
    const total = ${total};
    const slides = document.querySelectorAll('.slide');
    
    function show(n) {
      current = Math.max(0, Math.min(n, total - 1));
      slides.forEach((s, i) => s.classList.toggle('hidden', i !== current));
      document.getElementById('page').textContent = (current + 1) + ' / ' + total;
      document.getElementById('progress').style.width = ((current + 1) / total * 100) + '%';
    }
    
    function prev() { show(current - 1); }
    function next() { show(current + 1); }
    
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') prev();
      if (e.key === 'ArrowRight' || e.key === ' ') next();
      if (e.key === 'Home') show(0);
      if (e.key === 'End') show(total - 1);
    });
    
    show(0);
  `;

      const html = '<!DOCTYPE html>\n' +
'<html lang="ja">\n' +
'<head>\n' +
'  <meta charset="UTF-8">\n' +
'  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
'  <title>' + escapeHtml(meta.project || 'Presentation') + ' - FrameNote</title>\n' +
'  <link rel="preconnect" href="https://fonts.googleapis.com">\n' +
'  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>\n' +
'  <link href="' + googleFontsUrl + '" rel="stylesheet">\n' +
'  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">\n' +
'  <style>\n' +
'    * { margin: 0; padding: 0; box-sizing: border-box; }\n' +
'    body {\n' +
'      font-family: ' + fonts.body + ', sans-serif;\n' +
'      background: #000;\n' +
'      color: #fff;\n' +
'      height: 100vh;\n' +
'      display: flex;\n' +
'      flex-direction: column;\n' +
'      overflow: hidden;\n' +
'    }\n' +
'    .slide-container {\n' +
'      flex: 1;\n' +
'      display: flex;\n' +
'      align-items: center;\n' +
'      justify-content: center;\n' +
'      padding: 20px;\n' +
'    }\n' +
'    .slide {\n' +
'      width: 100%;\n' +
'      max-width: 1200px;\n' +
'      aspect-ratio: 16 / 9;\n' +
'      background: #fff;\n' +
'      border-radius: 8px;\n' +
'      overflow: hidden;\n' +
'      box-shadow: 0 4px 30px rgba(0,0,0,0.5);\n' +
'    }\n' +
'    .slide svg { width: 100%; height: 100%; }\n' +
'    .slide.hidden { display: none; }\n' +
'    .controls {\n' +
'      padding: 15px;\n' +
'      display: flex;\n' +
'      justify-content: center;\n' +
'      align-items: center;\n' +
'      gap: 15px;\n' +
'      background: #111;\n' +
'    }\n' +
'    .btn {\n' +
'      padding: 10px 20px;\n' +
'      border: 1px solid #333;\n' +
'      background: #1a1a1a;\n' +
'      color: #fff;\n' +
'      font-size: 14px;\n' +
'      border-radius: 6px;\n' +
'      cursor: pointer;\n' +
'      transition: all 0.15s;\n' +
'    }\n' +
'    .btn:hover { background: #2a2a2a; }\n' +
'    .page-info { font-size: 14px; color: #888; min-width: 80px; text-align: center; }\n' +
'    .progress { height: 3px; background: #333; }\n' +
'    .progress-bar { height: 100%; background: ' + theme.accent + '; transition: width 0.3s; }\n' +
'  </style>\n' +
'</head>\n' +
'<body>\n' +
'  <div class="progress"><div class="progress-bar" id="progress"></div></div>\n' +
'  <div class="slide-container">\n' +
'    ' + slideDivs + '\n' +
'  </div>\n' +
'  <div class="controls">\n' +
'    <button class="btn" onclick="prev()">‚óÄ Prev</button>\n' +
'    <span class="page-info" id="page">1 / ' + total + '</span>\n' +
'    <button class="btn" onclick="next()">Next ‚ñ∂</button>\n' +
'  </div>\n' +
'  <scr' + 'ipt>' + scriptContent + '</scr' + 'ipt>\n' +
'</body>\n' +
'</html>';

      // Download
      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      let filename = 'presentation';
      if (meta.project) {
        filename = meta.project.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
      }
      a.download = filename + '.html';
      a.click();
      URL.revokeObjectURL(url);
      
      showNotification('HTML exported successfully!', 'success');
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (document.getElementById('slideshow-modal').classList.contains('active')) return;
      if (e.target.closest('#monaco-container')) return;
      
      if (e.key === 'ArrowLeft') prevSlide();
      if (e.key === 'ArrowRight') nextSlide();
    });
  </script>
</body>
</html>
